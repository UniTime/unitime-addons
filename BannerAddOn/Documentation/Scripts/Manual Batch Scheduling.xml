<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="Tue Nov 10 13:38:47 EST 2015">
<script name="Manual Student Scheduling: CSV Export Enrollments" permission="Student Sectioning Solver" engine="python" created="Thu Nov 12 13:14:25 EST 2015">
  <description><![CDATA[<h3>Export student class enrollments of a course into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Course: students of this course offering will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>All Enrollments: include enrollments of other courses (checked) or just the entered course (unchecked)
<li>Drop Students: whether to drop the students from the course
</ul>]]></description>
  <parameter name="course" label="Course Offering" type="text"/>
  <parameter name="all" label="All Enrollments" type="boolean" default="false"/>
  <parameter name="drop" label="Drop Students" type="boolean" default="false"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from java.util import ArrayList, HashSet
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.banner.model import BannerSession, BannerSection
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.gwt.shared import SectioningException

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle")]
    crns = {}
    for enrl in student.getClassEnrollments():
        if all or enrl.getCourseOffering().getCourseName().lower() == course.lower():
            crns[enrl.getClazz().getExternalId(enrl.getCourseOffering())] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def getTermCode():
    return BannerSession.findBannerSessionForSession(session.getUniqueId(), hibSession).getBannerTermCode()

def getUser():
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def generateDropAction(online, student):
    action = EnrollStudent()
    action.forStudent(student.getUniqueId())
    
    request = online.execute(GetRequest().forStudent(student.getUniqueId()), getUser())
    assignments = ArrayList()
    enrollment = online.execute(GetAssignment().forStudent(student.getUniqueId()), getUser())
    for ca in enrollment.getCourseAssignments():
        if ca.isFreeTime() or ca.getCourseName().lower() == course.lower(): continue
        assignments.addAll(ca.getClassAssignments())

    action.withRequest(request)
    action.withAssignment(assignments)
    
    return action

def executeAction(server, action, student):
    if not action: return False
    enrollment = None
    try:
        enrollment = server.execute(action, getUser())
    except SectioningException, e:
        log.error('Drop failed: %s' % e.getMessage())
        return False
    for ca in enrollment.getCourseAssignments():
        if ca.isFreeTime(): continue
        sections = HashSet()
        for clazz in ca.getClassAssignments():
            if not sections.add(clazz.getSection()): continue
            if clazz.hasError():
                log.warn('%s %s: %s' % (ca.getCourseName(), clazz.getSection(), clazz.getError()))
    return True

def execute(online):
    students = hibSession.createQuery("select distinct e.student from StudentClassEnrollment e where e.student.session = :session and lower(e.courseOffering.subjectAreaAbbv || ' ' || e.courseOffering.courseNbr) = :course"
        ).setLong("session", session.getUniqueId()).setString("course", course.lower()).list()
    
    file = open(log.createOutput('%s_enrollments' % course,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in students:
        writer.writerow(getStudent(student))
        if online and drop:
            executeAction(online, generateDropAction(online, student), student)
    writer.writerow(['EOF'])
    file.close()

online = getOnlineServer()
if not course:
    log.error("No course offering was provided.")
else:
    execute(online)]]></body>
</script>
<script name="Manual Student Scheduling: CSV File Enroll" permission="Student Sectioning Solver" engine="python" created="Thu Nov 12 13:14:10 EST 2015">
  <description><![CDATA[<h3>Used the provided CSV file to enroll students on the online student scheduling server.</h3>
For each student that is included in the file, the appropriate Enroll action is created and executed on the online student scheduling server.<br>
<b>Input is expected in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, CRN1, CRN2, CRN3, ...
</ul>
<b>Output is returned in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, Course, CRN, Result, Error Message
</ul>
<b>Parameters:</b><ul>
<li>Class Enrollments: input file in the above format
<li>Clear Existing Enrollments: when true student enrollments are reset to what is in the file, otherwise the existing enrollments are extended with the enrollments in the file
<li>Name Columns: number of columns with student name
<li>Trim Leading Zeros: trim leading zeros from the PUID
</ul>]]></description>
  <parameter name="infile" label="Class Enrollments" type="file"/>
  <parameter name="trimLeadingZeros" label="Trim Leading Zeroes" type="boolean" default="false"/>
  <parameter name="clear" label="Clear Existing Enrollments" type="boolean" default="false"/>
  <parameter name="nameColumns" label="Name Columns" type="integer" default="1"/>
  <body><![CDATA[import csv
from java.util import ArrayList, HashSet
from java.lang import Long
from org.unitime.banner.model import BannerSection, BannerSession
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning.custom import RequestStudentUpdates
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.gwt.shared import SectioningException, CourseRequestInterface, ClassAssignmentInterface
from org.unitime.timetable.model import CourseDemand

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def getStudent(puid, name):
    student = hibSession.createQuery("from Student where session = :session and externalUniqueId = :puid"
        ).setLong("session", session.getUniqueId()).setString("puid", puid).uniqueResult()
    if not student:
        log.warn("Student %s (%s) does not exist." % (name, puid))
        return None
    return student

def getTermCode():
    return BannerSession.findBannerSessionForSession(session.getUniqueId(), hibSession).getBannerTermCode()

def getCourse(crn, term):
    co = BannerSection.findCourseOfferingForCrnAndTermCode(hibSession, int(crn), term)
    if not co:
        info.warn("No course offering found for CRN %s and banner session %s" % (crn, term))
    return co

def getClasses(crn, term):
    classes = HashSet()
    for clazz in BannerSection.findAllClassesForCrnAndTermCode(hibSession, int(crn), term):
        if session.equals(clazz.getSession()):
            classes.add(clazz)
    return classes

def getUser():
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def requestAddCourse(request, course):
    for r in request.getCourses():
        if r.hasRequestedFreeTime(): continue
        if r.getRequestedCourse() == course or r.getFirstAlternative() == course or r.getSecondAlternative() == course:
            return
    for r in request.getAlternatives():
        if r.getRequestedCourse() == course or r.getFirstAlternative() == course or r.getSecondAlternative() == course:
            return
    r = CourseRequestInterface.Request()
    r.setRequestedCourse(course)
    request.getCourses().add(r)
    
def assignmentsAddClass(assignments, course, clazz):
    for a in assignments:
        if a.isFreeTime(): continue
        if a.getCourseId() == course.getUniqueId() and a.getClassId() == clazz.getUniqueId(): return 
    a = ClassAssignmentInterface.ClassAssignment()
    a.setCourseId(course.getUniqueId())
    a.setClassId(clazz.getUniqueId())
    a.setSection(clazz.getClassSuffix(course))
    a.setClassNumber(clazz.getSectionNumberString(hibSession))
    assignments.add(a)

def assignmentsDropClasses(assignments, courseId):
    i = assignments.iterator()
    while i.hasNext():
        a = i.next()
        if not a.isFreeTime() and a.getCourseId() == courseId:
            i.remove()

def generateAction(online, student, crns):
    log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
    action = EnrollStudent()
    action.forStudent(student.getUniqueId())
    
    request = None
    assignments = ArrayList()
    if clear:
        request = CourseRequestInterface()
    else:
        request = online.execute(GetRequest().forStudent(student.getUniqueId()), getUser())
        enrollment = online.execute(GetAssignment().forStudent(student.getUniqueId()), getUser())
        for course in enrollment.getCourseAssignments():
            if course.isFreeTime(): continue
            assignments.addAll(course.getClassAssignments())

    term = getTermCode()
    courses = HashSet()
    for crn in crns:
        course = getCourse(crn, term)
        if not course: continue
        if course not in courses:
            courses.add(course)
            assignmentsDropClasses(assignments, course.getUniqueId())
        requestAddCourse(request, course.getCourseName())
        classes = getClasses(crn, term)
        for clazz in classes:
            assignmentsAddClass(assignments, course, clazz)

    action.withRequest(request)
    action.withAssignment(assignments)
    
    return action

def failStudent(server, action, student, writer, message):
    for assignment in action.getAssignment():
        course = server.getCourse(assignment.getCourseId())
        offering = server.getOffering(course.getOfferingId())
        section = offering.getSection(assignment.getClassId())
        writer.writerow([
            student.getExternalUniqueId(), student.getName("last-first-middle"),
            course.getCourseName(), section.getExternalId(assignment.getCourseId()),
            'Failed', message
            ])

def executeAction(server, action, student, writer):
    if not action: return False
    enrollment = None
    try:
        enrollment = server.execute(action, getUser())
    except SectioningException, e:
        log.error('Enrollment failed: %s' % e.getMessage())
        failStudent(server, action, student, writer, e.getMessage())
        return False
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        sections = HashSet()
        for clazz in course.getClassAssignments():
            if not sections.add(clazz.getSection()): continue
            line = [ student.getExternalUniqueId(), student.getName("last-first-middle"), '%s %s' % (course.getSubject(), course.getCourseNbr()), clazz.getSection() ]
            if clazz.isSaved(): line.append('Enrolled')
            else: line.append('Not Enrolled')
            if clazz.hasError():
                line.append(clazz.getError())
            if clazz.hasError():
                log.warn('%s %s %s: %s (%s)' % (course.getSubject(), course.getCourseNbr(), clazz.getSection(), clazz.getError(), line[5]))
            else:
                log.debug('%s %s %s' % (course.getSubject(), course.getCourseNbr(), clazz.getSection()))
            writer.writerow(line)
    return True

def execute(online):
    lines = csv.reader(infile.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
    outfile = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(outfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Status','Message'])
    failed = ArrayList()
    for line in lines:
        if not line: continue
        if line[0].lower() == 'puid' or line[0].lower() == 'eof': continue
        puid = line[0]
        while trimLeadingZeros and puid[0] == '0': puid = puid[1:]
        name = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        student = getStudent(puid, name)
        if not student: continue
        if not executeAction(online, generateAction(online, student, line[cstart:]), student, writer):
            failed.add(Long(student.getUniqueId()))
    writer.writerow(['EOF'])
    outfile.close()
    if failed.size() > 0:
        req = RequestStudentUpdates()
        req.forStudents(failed)
        online.execute(req, getUser())

online = getOnlineServer()
if not infile:
    log.error("Student file not provided.")
elif not online:
    log.error("Online student scheduling solver is not running.")
else:
    execute(online)]]></body>
</script>
<script name="Manual Student Scheduling: CSV File Enroll [XE]" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 13:46:31 EDT 2016">
  <description><![CDATA[<h3>Use the provided CSV file to enroll students via the Banner XE API.</h3>
<p>Input is expected in the CSV format.<br>There is a line for each student class enrollment:<br>PUID, Name, CRN1, CRN2, CRN3, ...</p>
<p>Output is returned in the CSV format.<br>There is a line for each student class enrollment:<br>PUID, Name, Course, CRN, Request, Registration Status, Error Message, Used Override</p>
<p><b>Parameters:</b><ul>
<li>Class Enrollments: input file in the above format
<li>Name Columns: number of columns with student name
<li>Automatic Overrides: check to use automatic overrides
<li>Allowed Overrides: list of overrides that can be used (when enabled)
<li>Manual Overrides: list of overrides that are manually put in
<li>Conditional Add Drop: check if conditional add drop is to be enabled
<li>Hold Password: enter hold password if students with hold should be enrolled
<li>Registration Date: for back-dating enter registration date (in yyyy-mm-dd format)
</ul></p>]]></description>
  <parameter name="input" label="1. Class Enrollments" type="file"/>
  <parameter name="nameColumns" label="2. Name Columns" type="enum(0,1,2,3)" default="1"/>
  <parameter name="autoOverrides" label="3. Automatic Overrides" type="boolean" default="false"/>
  <parameter name="ovCampus" label="4a. Allow Override CAMPUS" type="boolean" default="true"/>
  <parameter name="ovClass" label="4b. Allow Override CLASS" type="boolean" default="true"/>
  <parameter name="ovClosed" label="4c. Allow Override CLOSED" type="boolean" default="false"/>
  <parameter name="ovCoReq" label="4d. Allow Override CO-REQ" type="boolean" default="true"/>
  <parameter name="ovCollege" label="4e. Allow Override COLLEGE" type="boolean" default="true"/>
  <parameter name="ovDegree" label="4f. Allow Override DEGREE" type="boolean" default="true"/>
  <parameter name="ovDptPermit" label="4g. Allow Override DPT-PERMIT" type="boolean" default="true"/>
  <parameter name="ovDupCrse" label="4h. Allow Override DUP-CRSE" type="boolean" default="true"/>
  <parameter name="ovHonors" label="4i. Allow Override HONORS" type="boolean" default="true"/>
  <parameter name="ovInstPermit" label="4j. Allow Override INST-PERMIT" type="boolean" default="true"/>
  <parameter name="ovLevel" label="4k. Allow Override LEVEL" type="boolean" default="true"/>
  <parameter name="ovMajor" label="4l. Allow Override MAJOR" type="boolean" default="true"/>
  <parameter name="ovPreReq" label="4m. Allow Override PRE-REQ" type="boolean" default="false"/>
  <parameter name="ovProgram" label="4n. Allow Override PROGRAM" type="boolean" default="true"/>
  <parameter name="ovTimeCnflt" label="4o. Allow Override TIME-CNFLT" type="boolean" default="false"/>
  <parameter name="overrides" label="5. Manual Overrides" type="textarea" default="PUID,CRN,Override (one override per line)"/>
  <parameter name="conditionalAddDrop" label="6. Conditional Add Drop" type="boolean" default="true"/>
  <parameter name="holdPassword" label="7. Hold Password" type="text"/>
  <parameter name="registrationDate" label="8. Registration Date (yyyy-mm-dd)" type="text"/>
  <parameter name="actionAdd" label="9a. Registration Status ADD" type="enum(RE,RW)" default="RE"/>
  <parameter name="actionDrop" label="9b. Registration Status DROP" type="enum(DD,DW,DDD,CA,NO DROP)" default="DDD"/>
  <body><![CDATA[import csv
from xml.dom import minidom
from java.lang import Long
from java.util import ArrayList, HashSet, Date
from java.io import StringReader
from org.dom4j.io import SAXReader
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable import ApplicationProperties
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.banner.model import BannerSession, QueueOut

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getCourseNameForCrn(crn):
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()
    if course:
        return course.getCourseName()
    return None

def getConsent(crn):
    return hibSession.createQuery(
        "select co.consentType.reference from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId"
        ).setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()

def getDefaultOverride(crn, messageType):
    if messageType == 'DEPT' or messageType == 'SAPR':
        consent = getConsent(crn)
        if consent == "IN": return "INST-PERMT"
        elif consent == "DP": return "DPT-PERMIT"
        else: return "HONORS"
    elif messageType in defaultOverrides:
        return defaultOverrides[messageType]
    else:
        return None

def getManualOverride(puid, crn, manualOverrides):
    if not manualOverrides: return None
    for line in manualOverrides:
        if not line: continue
        if not line[0] or line[0].strip().zfill(9) == puid:
            if line[1] and line[1].strip() == crn:
                return line[2].strip()
    return None

def addOverride(req, id, override, overrides):
    if id in overrides and override in overrides[id]: return False
    for crn in req.courseReferenceNumbers:
        if crn.courseReferenceNumber == id:
            log.debug('Adding override %s for %s' % (override, id))
            crn.courseOverride = override
            if id not in overrides:
                overrides[id] = [override]
            else:
                overrides[id].append(override)
            return True
    log.warn('Failed to add override %s for %s' % (override, id))
    return False

def getOverride(req, id, overrides):
    if overrides and id in overrides:
        return ','.join(overrides[id])
    elif req.courseReferenceNumbers:
        for crn in req.courseReferenceNumbers:
            if crn.courseReferenceNumber == id:
                return crn.courseOverride
    return None

def handleError(resource, e):
    error = None
    if resource.getResponseEntity():
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        if response: error = response.getError()
    if error and error.message:
        raise SectioningException(error.message)
    if error and error.description:
        raise SectioningException(error.description)
    if error and error.errorMessage:
        raise SectioningException(error.errorMessage)
    raise SectioningException(e.getMessage())

def getSchedule(resource):
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e: handleError(resource, e)

    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)

    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if m == "Holds prevent registration." and holdPassword:
                    return getHoldSchedule(resource)
                if m == "Invalid or undefined Enrollment Status or date range invalid." and registrationDate:
                    return getHoldSchedule(resource)
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return original

def getHoldSchedule(resource):
    if holdPassword:
        log.debug("Using hold password...")
    elif registrationDate:
        log.debug("Using registration date...")
    term = resource.getQueryValue("term")
    puid = resource.getQueryValue("bannerId")
    req = XEInterface.RegisterRequest(term, puid, None, True)
    req.empty()
    if holdPassword:
        req.holdPassword = holdPassword
    if registrationDate:
        req.registrationDate = registrationDate

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()

    if not response:
        raise SectioningException("Failed to check student registration status.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return response

def postChanges(resource, req):
    if req.isEmpty(): req.empty()

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()

    if not response:
        raise SectioningException("Failed to enroll student.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to enroll student.")

    return response

def isAllowedOverride(override):
    if override == 'CAMPUS': return ovCampus
    if override == 'CLASS': return ovClass
    if override == 'CLOSED': return ovClosed
    if override == 'COLLEGE': return ovCollege
    if override == 'CO-REQ': return ovCoReq
    if override == 'DEGREE': return ovDegree
    if override == 'DPT-PERMIT': return ovDptPermit
    if override == 'INST-PERMT': return ovInstPermit
    if override == 'HONORS': return ovHonors
    if override == 'DUP-CRSE': return ovDupCrse
    if override == 'LEVEL': return ovLevel
    if override == 'MAJOR': return ovMajor
    if override == 'PRE-REQ': return ovPreReq
    if override == 'PROGRAM': return ovProgram
    if override == 'TIME-CNFLT': return ovTimeCnflt
    if override == 'COHORT': return ovCohort
    return False

def add(req, id, changeStatus):
    if not actionAdd:
        req.add(id, changeStatus)
    elif changeStatus:
        if not req.actionsAndOptions: req.actionsAndOptions = ArrayList()
        req.actionsAndOptions.add(XEInterface.RegisterAction(actionAdd, id))
    else:
        if not req.courseReferenceNumbers: req.courseReferenceNumbers = ArrayList()
        req.courseReferenceNumbers.add(XEInterface.CourseReferenceNumber(id, actionAdd))

def keep(req, id):
    req.keep(id)

def drop(req, id):
    if not actionDrop:
        req.drop(id)
    elif actionDrop == "NO DROP":
        if not req.courseReferenceNumbers: req.courseReferenceNumbers = ArrayList()
        req.courseReferenceNumbers.add(XEInterface.CourseReferenceNumber(id, actionAdd))
    else:
        if not req.actionsAndOptions: req.actionsAndOptions = ArrayList()
        req.actionsAndOptions.add(XEInterface.RegisterAction(actionDrop, id))

def enroll(client, puid, name, crns, writer, manualOverrides):
    log.info('%s: %s [%s]' % (puid, name, ','.join(crns)))
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    puid = puid.zfill(9)

    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", puid)
    resource.addQueryParameter("systemIn", "SB")
    resource.addQueryParameter("persona", "SB")
    if holdPassword:
        resource.addQueryParameter("holdPassword", holdPassword)

    original = getSchedule(resource)

    noadd = HashSet()
    nodrop = HashSet()
    notregistered = HashSet()
    registered = {}
    if original.registrations:
        for reg in original.registrations:
            if reg.isRegistered():
                registered[reg.courseReferenceNumber] = reg
                if not reg.can(actionDrop):
                    nodrop.add(reg.courseReferenceNumber)
            else:
                notregistered.add(reg.courseReferenceNumber)
                if not reg.can(actionAdd):
                    noadd.add(reg.courseReferenceNumber)

    added = HashSet()
    req = XEInterface.RegisterRequest(term, puid, None, True)
    if holdPassword:
        req.holdPassword = holdPassword
    for id in crns:
        if not id: continue
        if not id in registered and noadd.contains(id):
            writer.writerow([
                puid, name,
                getCourseNameForCrn(id), id,
                'Failed', 'Action %s is not allowed.' % actionAdd
            ])
        else:
            if id in registered:
                if added.add(id): keep(req, id)
            else:
                if added.add(id): add(req, id, notregistered.contains(id))
    for id in registered.keys():
        if added.contains(id): continue
        reg = registered[id]
        if not campus == reg.campus:
            if added.add(id): keep(req, id)
        elif nodrop.contains(id):
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                'Failed', 'Action %s is not allowed.' % actionDrop
            ])
            if added.add(id): keep(req, id)
        else:
            drop(req, id)

    appliedOverrides = {}
    for id in crns:
        override = getManualOverride(puid, id, manualOverrides)
        if override: addOverride(req, id, override, appliedOverrides)

    if registrationDate:
        req.registrationDate = registrationDate
    if conditionalAddDrop:
        req.conditionalAddDrop = "Y"

    response = postChanges(resource, req)

    while autoOverrides and response.registrations:
        changed = False
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            if reg.crnErrors and id in crns:
                for e in reg.crnErrors:
                    override = getDefaultOverride(id, e.messageType)
                    if override and isAllowedOverride(override):
                        if addOverride(req, id, override, appliedOverrides):
                            changed = True
                        break

        if not changed: break
        response = postChanges(resource, req)

    checked = HashSet()
    if response.registrations:
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            checked.add(id)
            op = None
            if added.contains(id):
                op = "Add"
            else:
                op = "Drop"
                if id in notregistered: continue
            error = None
            errorType = []
            if reg.crnErrors:
                for e in reg.crnErrors:
                    if not error:
                        error = '%s: %s' % (e.messageType, e.message)
                    else:
                        error = "%s\n%s: %s" % (error, e.messageType, e.message)
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                op, reg.statusDescription, error, getOverride(req, id, appliedOverrides)
            ])
            if error: log.warn('%s: %s' % (id, error))

    if response.failedRegistrations:
        for reg in response.failedRegistrations:
            if not reg.failedCRN or not reg.failure: continue
            id = reg.failedCRN
            checked.add(id)
            op = None
            if added.contains(id): op = "Add"
            else: op = "Drop"
            error = reg.failure
            writer.writerow([
                puid, name,
                getCourseNameForCrn(id), id,
                op, 'Failed', error, getOverride(req, id, appliedOverrides)
            ])
            log.warn('%s: %s' % (id, error))

    ex = False
    for id in crns:
        if not id: continue
        if checked.contains(id): continue
        op = None
        if added.contains(id): op = "Add"
        else: op = "Drop"
        ex = True
        writer.writerow([
            puid, name,
            getCourseNameForCrn(id), id,
            op, 'Exception', response.registrationException])

    if response.registrationException and not ex:
        writer.writerow([
            puid, name,
            None, None,
            None, 'Exception', response.registrationException])

    if response.registrationException: log.warn(response.registrationException)

    resource.release()

def failStudent(puid, name, crns, writer, message):
    for id in crns:
        if not id: continue
        writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Add', 'Failed', message])

def createStudentRequestUpdateMessage(puids):
    term = BannerTermProvider().getExternalTerm(AcademicSessionInfo(session))
    doc = minidom.getDOMImplementation().createDocument(None, "studentUpdateRequest", None)
    root = doc.documentElement
    for puid in puids:
        studentEl = doc.createElement("student")
        studentEl.setAttribute("externalId", puid.zfill(9))
        studentEl.setAttribute("session", term)
        root.appendChild(studentEl)
    return doc.toprettyxml()

def requestStudentUpdate(puids):
    log.info('Requesting student update...')
    message = createStudentRequestUpdateMessage(puids)
    out = QueueOut()
    out.setXml(SAXReader().read(StringReader(message)))
    out.setStatus(QueueOut.STATUS_READY)
    out.setPostDate(Date())
    hibSession.save(out)

defaultOverrides = {
    'CAMP': 'CAMPUS',
    'CLAS': 'CLASS',
    'CLOS': 'CLOSED',
    'COLL': 'COLLEGE',
    'CORQ': 'CO-REQ',
    'DEGR': 'DEGREE',
    'DEPT': 'DPT-PERMIT',
    'DUPL': 'DUP-CRSE',
    'LEVL': 'LEVEL',
    'MAJR': 'MAJOR',
    'PREQ': 'PRE-REQ',
    'PROG': 'PROGRAM',
    'TIME': 'TIME-CNFLT',
    'CHRT': 'COHORT',
    }

def execute():
    manualOverrides = None
    if overrides:
        manualOverrides = []
        for line in csv.reader(overrides.split('\n'), delimiter=",", quotechar='"'):
            manualOverrides.append(line)
    lines = []
    for line in csv.reader(input.getString('utf-8').split('\n'), delimiter=",", quotechar='"'):
        if not line: continue
        if line[0].lower() == 'puid' or line[0].lower() == 'eof': continue
        lines.append(line)
    output = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Request','Status','Message','Used Override'])
    client = getClient()
    puids = []
    log.setStatus('Enrolling students', len(lines))
    for line in lines:
        puid = line[0]
        name = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        puids.append(puid)
        try:
            enroll(client, puid, name, line[cstart:], writer, manualOverrides)
        except SectioningException, e:
            log.error('Enrollment failed: %s' % e.getMessage())
            failStudent(puid, name, line[cstart:], writer, e.getMessage())
        log.incProgress()
    writer.writerow(['EOF'])
    output.close()
    client.stop()
    if puids:
        requestStudentUpdate(puids)

if not input:
    log.error("Class enrollments file not provided.")
else:
    execute()]]></body>
</script>
<script name="Manual Student Scheduling: CSV File DROP [XE]" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 14:51:56 EDT 2016">
  <description><![CDATA[<h3>Use the provided CSV file to <font color='red'>DROP</font> students via the Banner XE API.</h3>
<p>Input is expected in the CSV format.<br>There is a line for each student:<br>PUID, Name, CRN1, CRN2, CRN3, ...</p>
<p>Output is returned in the CSV format.<br>There is a line for each student drop:<br>PUID, Name, Course, CRN, Registration Status, Error Message</p>
<p><b>Parameters:</b><ul>
<li>Student Drop File: input file in the above format
<li>Name Columns: number of columns with student name
<li>Mode: student will be dropped from all his/her classes when set to Drop All CRNs
<li>Conditional Add Drop: check if conditional add drop is to be enabled
<li>Hold Password: enter hold password if students with hold should be enrolled
<li>Registration Date: for back-dating enter registration date (in yyyy-mm-dd format)
</ul></p>]]></description>
  <parameter name="holdPassword" label="5. Hold Password" type="text"/>
  <parameter name="registrationDate" label="6. Registration Date (yyyy-mm-dd)" type="text"/>
  <parameter name="input" label="1. Student Drop File" type="file"/>
  <parameter name="mode" label="3. Mode" type="enum(Drop All CRNs,Drop Listed CRNs)" default="Drop Listed CRNs"/>
  <parameter name="conditionalAddDrop" label="4. Conditional Add Drop" type="boolean" default="true"/>
  <parameter name="nameColumns" label="2. Name Columns" type="enum(0,1,2,3)" default="1"/>
  <parameter name="actionDrop" label="7. Registration Status DROP" type="enum(DD,DW,DDD,CA)" default="DDD"/>
  <body><![CDATA[import csv
from xml.dom import minidom
from java.lang import Long
from java.util import ArrayList, HashSet, Date
from java.io import StringReader
from org.dom4j.io import SAXReader
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable import ApplicationProperties
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.banner.model import BannerSession, QueueOut

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getCourseNameForCrn(crn):
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()
    if course:
        return course.getCourseName()
    return None

def handleError(resource, e):
    error = None
    if resource.getResponseEntity():
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        if response: error = response.getError()
    if error and error.message:            
        raise SectioningException(error.message)
    if error and error.description:
        raise SectioningException(error.description)
    if error and error.errorMessage:
        raise SectioningException(error.errorMessage)
    raise SectioningException(e.getMessage())

def getSchedule(resource):
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e: handleError(resource, e)
    
    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)
    
    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if m == "Holds prevent registration." and holdPassword:
                    return getHoldSchedule(resource)
                if m == "Invalid or undefined Enrollment Status or date range invalid." and registrationDate:
                    return getHoldSchedule(resource)
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")
    
    return original

def getHoldSchedule(resource):
    if holdPassword:
        log.debug("Using hold password...")
    elif registrationDate:
        log.debug("Using registration date...")
    term = resource.getQueryValue("term")
    puid = resource.getQueryValue("bannerId")
    req = XEInterface.RegisterRequest(term, puid, None, True)
    req.empty()
    if holdPassword:
        req.holdPassword = holdPassword
    if registrationDate:
        req.registrationDate = registrationDate
    
    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)
    
    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()
    
    if not response:
        raise SectioningException("Failed to check student registration status.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")
    
    return response

def postChanges(resource, req):
    if req.isEmpty(): req.empty()

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()
    
    if not response:
        raise SectioningException("Failed to enroll student.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to enroll student.")

    return response

def keep(req, id):
    req.keep(id)

def drop(req, id):
    if not actionDrop:
        req.drop(id)
    else:
        if not req.actionsAndOptions: req.actionsAndOptions = ArrayList()
        req.actionsAndOptions.add(XEInterface.RegisterAction(actionDrop, id))

def enroll(client, puid, name, crns, writer):
    if crns:
        log.info('%s: %s [%s]' % (puid, name, ','.join(crns)))
    else:
        log.info('%s: %s' % (puid, name))
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    puid = puid.zfill(9)
    
    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", puid)
    resource.addQueryParameter("systemIn", "SB")
    resource.addQueryParameter("persona", "SB")
    if holdPassword:
        resource.addQueryParameter("holdPassword", holdPassword)

    original = getSchedule(resource)
    
    registration = {}
    if original.registrations:
        for reg in original.registrations:
            registration[reg.courseReferenceNumber] = reg
    
    req = XEInterface.RegisterRequest(term, puid, None, True)
    if holdPassword:
        req.holdPassword = holdPassword

    dropped = HashSet()    
    if crns:
        for id in crns:
            if not id: continue
            if not id in registration:
                writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Dropped', 'Already not present in the registration.'])
                continue
            reg = registration[id]
            if reg.isRegistered():
                if reg.can(actionDrop):
                    drop(req, id)
                    dropped.add(id)
                else:
                    writer.writerow([puid, name, '%s %s' % (reg.subject, reg.courseNumber), id, 'Failed', 'Action %s is not allowed.' % actionDrop])
                    keep(req, id)
            else:
                if reg.can(actionDrop):
                    drop(req, id)
                    dropped.add(id)
    
    if original.registrations:
        for reg in original.registrations:
            id = reg.courseReferenceNumber
            if crns:
                if dropped.contains(id): continue
                elif reg.isRegistered(): keep(req, id)
            elif reg.isRegistered():
                if reg.can(actionDrop):
                    drop(req, id)
                    dropped.add(id)
                else:
                    writer.writerow([puid, name, '%s %s' % (reg.subject, reg.courseNumber), id, 'Failed', 'Action %s is not allowed.' % actionDrop])
                    keep(req, id)
            
    if registrationDate:
        req.registrationDate = registrationDate
    if conditionalAddDrop:
        req.conditionalAddDrop = "Y"

    response = postChanges(resource, req)
    
    checked = HashSet()
    if response.registrations:
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            checked.add(id)
            if not dropped.contains(id) and not reg.crnErrors: continue
            error = None
            errorType = []
            if reg.crnErrors:
                for e in reg.crnErrors:
                    if not error:
                        error = '%s: %s' % (e.messageType, e.message)
                    else:
                        error = "%s\n%s: %s" % (error, e.messageType, e.message)
            writer.writerow([puid, name, '%s %s' % (reg.subject, reg.courseNumber), id, reg.statusDescription, error])
            if error: log.warn('%s: %s' % (id, error))
    
    if response.failedRegistrations:
        for reg in response.failedRegistrations:
            if not reg.failedCRN or not reg.failure: continue
            id = reg.failedCRN
            checked.add(id)
            error = reg.failure
            writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Failed', error])
            log.warn('%s: %s' % (id, error))
   
    ex = False
    for id in dropped:
        if not id: continue
        if checked.contains(id): continue
        ex = True
        writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Exception', response.registrationException])
        
    if response.registrationException and not ex:
        writer.writerow([puid, name, None, None, None, 'Exception', response.registrationException])
        
    if response.registrationException: log.warn(response.registrationException)
    
    resource.release()

def failStudent(puid, name, crns, writer, message):
    if crns:
        for id in crns:
            if not id: continue
            writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Failed', message])
    else:
        writer.writerow([puid, name, None, None, 'Failed', message])

def createStudentRequestUpdateMessage(puids):
    term = BannerTermProvider().getExternalTerm(AcademicSessionInfo(session))
    doc = minidom.getDOMImplementation().createDocument(None, "studentUpdateRequest", None)
    root = doc.documentElement
    for puid in puids:
        studentEl = doc.createElement("student")
        studentEl.setAttribute("externalId", puid.zfill(9))
        studentEl.setAttribute("session", term)
        root.appendChild(studentEl)
    return doc.toprettyxml()

def requestStudentUpdate(puids):
    log.info('Requesting student update...')
    message = createStudentRequestUpdateMessage(puids)
    out = QueueOut()
    out.setXml(SAXReader().read(StringReader(message)))
    out.setStatus(QueueOut.STATUS_READY)
    out.setPostDate(Date())
    hibSession.save(out)

def execute():
    lines = []
    for line in csv.reader(input.getString('utf-8').split('\n'), delimiter=",", quotechar='"'):
        if not line: continue
        if line[0].lower() == 'puid' or line[0].lower() == 'eof': continue
        lines.append(line)
    output = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Status','Message'])
    client = getClient()
    puids = []
    log.setStatus('Dropping students', len(lines))
    for line in lines:
        puid = line[0]
        name = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        puids.append(puid)
        try:
            if mode == "Drop All CRNs":
                enroll(client, puid, name, None, writer)
            else:
                crns = []
                for crn in line[cstart:]:
                    if crn: crns.append(crn)
                if crns:
                     enroll(client, puid, name, crns, writer)
        except SectioningException, e:
            log.error('Drop failed: %s' % e.getMessage())
            failStudent(puid, name, line[cstart:], writer, e.getMessage())
        log.incProgress()
    writer.writerow(['EOF'])
    output.close()
    client.stop()
    if puids:
        requestStudentUpdate(puids)

if not input:
    log.error("Student drop file not provided.")
else:
    execute()]]></body>
</script>
</scripts>
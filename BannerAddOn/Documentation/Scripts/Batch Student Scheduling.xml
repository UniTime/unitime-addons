<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="Tue Oct 20 15:00 CEST 2015">
<script name="Batch Student Scheduling: Data Import" permission="Student Sectioning Solver" engine="python" created="Thu Mar 16 16:53:05 CET 2017">
  <description><![CDATA[<h3>Import student course requests from the given CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, Course1, Course2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Input File: CSV file in the above format
<li>Status: student status to be set (if selected)
<li>Trim Leading Zeros: trim leading zeros from the PUID
<li>Create Individual Reservations: if a course is identified by one or more CRNs,<br>also create individual reservation for the student to get the listed sections
<li>Clear Existing Demands: replace existing student course demands with the given demands
<li>Create Limit Overrides: create limit override reservations for the imported students
<li>Name Columns: number of columns with student name
</ul>]]></description>
  <parameter name="clear" label="Clear Existing Demands" type="boolean" default="false"/>
  <parameter name="individual" label="Create Individual Reservations" type="boolean" default="true"/>
  <parameter name="file" label="Input File (CSV)" type="file"/>
  <parameter name="override" label="Create Limit Overrides" type="boolean" default="false"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="trimLeadingZeros" label="Trim Leading Zeros" type="boolean" default="true"/>
  <parameter name="nameColumns" label="Name Columns" type="enum(0,1,2,3)" default="1"/>
  <body><![CDATA[import csv
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.model import UserData, StudentSectioningStatus, CourseDemand, CourseRequest, OverrideReservation, StudentSectioningQueue, IndividualReservation
from org.unitime.timetable.onlinesectioning.updates import ReloadStudent
from java.util import HashSet, Date
from java.lang import Long

def isOverrideNeeded(offering):
    for config in offering.getInstrOfferingConfigs():
        canEnroll = True
        for subpart in config.getSchedulingSubparts():
            hasEnabledClazz = False
            for clazz in subpart.getClasses():
                if clazz.isEnabledForStudentScheduling():
                    hasEnabledClazz = True
                    break
            if not hasEnabledClazz:
                canEnroll = False
                break
        if canEnroll: return False
    return True

def getStudent(puid, name, clear):
    student = hibSession.createQuery("from Student where session = :session and externalUniqueId = :puid"
        ).setLong("session", session.getUniqueId()).setString("puid", puid).uniqueResult()
    if not student:
        log.warn("Student %s (%s) does not exist." % (name, puid))
        return None
    log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
    if clear:
        offerings = HashSet()
        for cd in student.getCourseDemands():
            if cd.getFreeTime():
                hibSession.delete(cd.getFreeTime())
            for cr in cd.getCourseRequests():
                offerings.add(cr.getCourseOffering().getInstructionalOffering())
                hibSession.delete(cr)
            hibSession.delete(cd)
        student.getCourseDemands().clear()
        for enrl in student.getClassEnrollments():
            hibSession.delete(enrl)
        student.getClassEnrollments().clear()
        if override:
            for offering in offerings:
                reservation = hibSession.createQuery(
                    "select r from OverrideReservation r inner join r.students s where s.uniqueId = :studentId and r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
                    ).setLong("offeringId", offering.getUniqueId()).setLong("studentId", student.getUniqueId()).setMaxResults(1).uniqueResult()
                if reservation:
                    reservation.getStudents().remove(student)
                    if reservation.getStudents().isEmpty(): hibSession.delete(reservation)
                    else: hibSession.saveOrUpdate(reservation)
        if individual:
            for offering in offerings:
                reservation = hibSession.createQuery(
                    "select r from IndividualReservation r inner join r.students s where s.uniqueId = :studentId and r.instructionalOffering = :offeringId"
                    ).setLong("offeringId", offering.getUniqueId()).setLong("studentId", student.getUniqueId()).setMaxResults(1).uniqueResult()
                if reservation:
                    reservation.getStudents().remove(student)
                    if reservation.getStudents().isEmpty(): hibSession.delete(reservation)
                    else: hibSession.saveOrUpdate(reservation)
    return student


def addCourse(student, course, classes, ts, offeringIds):
    priority = 0
    for cd in student.getCourseDemands():
        if priority <= cd.getPriority() and not cd.isAlternative(): priority = cd.getPriority() + 1
        for cr in cd.getCourseRequests():
            if course == cr.getCourseOffering():
                log.warn("-- course is already requested")
                return False
    cd = CourseDemand()
    cd.setCourseRequests(HashSet())
    cd.setStudent(student)
    student.getCourseDemands().add(cd)
    cd.setAlternative(False)
    cd.setPriority(priority)
    cd.setWaitlist(False)
    cd.setTimestamp(ts)
    cr = CourseRequest()
    cd.getCourseRequests().add(cr)
    cr.setCourseDemand(cd)
    cr.setAllowOverlap(False)
    cr.setCredit(0)
    cr.setOrder(0)
    cr.setCourseOffering(course)
    if individual and classes:
        for clazz in classes:
            parent = clazz.getParentClass()
            while parent:
                if parent in classes: classes.remove(parent)
                parent = parent.getParentClass()
        log.debug("-- creating individual reservation for %s" % course.getCourseName())
        reservation = None
        for r in hibSession.createQuery("from IndividualReservation r where r.instructionalOffering = :offeringId and r.configurations is empty"
                                        ).setLong("offeringId", course.getInstructionalOffering().getUniqueId()).list():
            if r.getClasses().size() != len(classes): continue
            match = True
            for c in classes:
                if not r.getClasses().contains(c):
                    match = False
                    break
            if match:
                reservation = r
                break
        if not reservation:
            reservation = IndividualReservation()
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setConfigurations(HashSet())
            reservation.setStudents(HashSet())
            for c in classes:
                reservation.getClasses().add(c)
            offeringIds.add(Long(course.getInstructionalOffering().getUniqueId()))
        reservation.getStudents().add(student)
        hibSession.saveOrUpdate(reservation)
    elif override and isOverrideNeeded(course.getInstructionalOffering()):
        log.debug("-- creating override for %s" % course.getCourseName())
        reservation = hibSession.createQuery(
            "from OverrideReservation r where r.instructionalOffering = :offeringId and r.type = 1 and r.configurations is empty and r.classes is empty"
            ).setLong("offeringId", course.getInstructionalOffering().getUniqueId()).setMaxResults(1).uniqueResult()
        if not reservation:
            reservation = OverrideReservation()
            reservation.setType(1)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setConfigurations(HashSet())
            reservation.setStudents(HashSet())
            offeringIds.add(Long(course.getInstructionalOffering().getUniqueId()))
        reservation.getStudents().add(student)
        hibSession.saveOrUpdate(reservation)
    return True

def setStatus(student, status):
    student.setSectioningStatus(status)

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def lookupCourse(cn, courses, restrictions):
    if not cn:
        log.debug("Empty slot skipped.")
        return
    try:
        crn = int(cn)
        clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
        course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
        if not course or not clazz:
            log.error("Class %d not found." % crn)
            return
        log.debug(clazz.getClassLabelWithTitle(course))
        if course not in courses:
            courses.append(course)
        if course not in restrictions:
            restrictions[course] = [clazz]
        else:
            restrictions[course].append(clazz)
    except ValueError:
        course = hibSession.createQuery("from CourseOffering where subjectArea.session = :session and subjectAreaAbbv || ' ' || courseNbr = :name").setLong("session", session.getUniqueId()).setString("name", cn).uniqueResult()
        if not course:
            log.warn("Course %s does not exist." % cn)
            return
        log.debug(course.getCourseNameWithTitle())
        if course not in courses:
            courses.append(course)

def execute():
    lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
    status = None
    if statusRef:
        status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)
        log.info("Using status %s - %s" % (status.getReference(), status.getLabel()))
    ts = Date()
    studentIds = HashSet()
    offeringIds = HashSet()
    for line in lines:
        if not line: continue
        if line[0].lower() == 'puid' or line[0].lower() == 'eof': continue
        puid = line[0]
        if not puid: continue
        while trimLeadingZeros and puid[0] == '0': puid = puid[1:]
        name = None
        cstart = 1
        for i in range(0, int(nameColumns)):
            if name:
                name = "%s %s" % (name, line[cstart].strip())
            else:
                name = line[cstart].strip()
            cstart = cstart + 1
        student = getStudent(puid, name, clear)
        if not student: continue
        courses = []
        restrictions = {}
        for course in line[cstart:]:
            lookupCourse(course, courses, restrictions)
        for course in courses:
            classes = None
            if course in restrictions:
                classes = restrictions[course]
            addCourse(student, course, classes, ts, offeringIds)
        if status:
            setStatus(student, status)
        studentIds.add(Long(student.getUniqueId()))
        hibSession.saveOrUpdate(student)

    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), studentIds)

    if offeringIds.size() > 0:
        StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offeringIds)

if not file:
    log.error("No input file was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Class Enrollments]" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 15:01:29 EDT 2016">
  <description><![CDATA[<h3>Export student class enrollments into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
</ul>]]></description>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle")]
    crns = {}
    for enrl in student.getClassEnrollments():
        crns[enrl.getClazz().getExternalId(enrl.getCourseOffering())] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_enrollments' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Data Export [Courses]" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 15:01:17 EDT 2016">
  <description><![CDATA[<h3>Export student course demands into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, PIN, Course1, Course2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Status: students of this status will be exported
<li>Add Leading Zeros: add leading zeros to the PUID
<li>Default PIN: default PIN number to be used in the enrollment
</ul>]]></description>
  <parameter name="status" label="Status" type="reference(StudentSectioningStatus)"/>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData

def getStudent(student):
    puid = student.getExternalUniqueId()
    if zeros: puid = puid.zfill(9)
    log.info("%s %s" % (puid, student.getName("last-first-middle")))
    line = [puid, student.getName("last-first-middle")]
    courses = {}
    for enrl in student.getClassEnrollments():
        courses[enrl.getCourseOffering().getCourseName()] = True
    for cd in student.getCourseDemands():
        if cd.isAlternative(): continue
        for cr in cd.getCourseRequests():
            if cr.getOrder() == 0:
                courses[cr.getCourseOffering().getCourseName()] = True
    line.extend(sorted(courses.keys()))
    log.debug('-- %s' % ','.join(sorted(courses.keys())))
    return line

def execute():
    students = hibSession.createQuery("from Student where session = :session and sectioningStatus.reference = :status"
        ).setLong("session", session.getUniqueId()).setString("status", status).list()
    
    file = open(log.createOutput('%s_courses' % status,'csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','Course','Course','Course'])
    for student in students:
        writer.writerow(getStudent(student))
    writer.writerow(['EOF'])
    file.close()

if not status:
    log.error("No student status was provided.")
else:
    execute()]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 15:09:18 EDT 2016">
  <description><![CDATA[<h3>Used the batch student scheduling solver solution to enroll students on the online student scheduling server.</h3>
For each student that is loaded in the solver, the appropriate Enroll action is created and executed on the online student scheduling server.<br>
<b>Output is returned in the following CSV format:</b><ul>
<li>There is a line for each student class enrollment
<li>PUID, Name, Course, CRN, Result, Error Message
</ul>]]></description>
  <body><![CDATA[import csv
from java.util import ArrayList, HashSet
from java.lang import Long
from org.unitime.timetable.model import UserData
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest
from org.unitime.timetable.onlinesectioning.basic import GetRequest, GetAssignment
from org.unitime.timetable.onlinesectioning.updates import EnrollStudent
from org.unitime.timetable.onlinesectioning.custom import RequestStudentUpdates
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.gwt.shared import SectioningException

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getOnlineServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getOnlineStudentSchedulingContainer()
    server = container.getSolver(str(session.getUniqueId()))
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def getUser(student):
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def generateAction(server, student):
    log.info("%s %s" % (student.getExternalId(), student.getName()))
    action = EnrollStudent()
    action.forStudent(student.getStudentId())
    
    request = server.execute(GetRequest().forStudent(student.getStudentId()), getUser(student))
    action.withRequest(request)

    enrollment = server.execute(GetAssignment().forStudent(student.getStudentId()), getUser(student))
    assignments = ArrayList()
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        assignments.addAll(course.getClassAssignments())
    action.withAssignment(assignments)
    
    return action

def failStudent(server, action, student, writer, message):
    for assignment in action.getAssignment():
        course = server.getCourse(assignment.getCourseId())
        offering = server.getOffering(course.getOfferingId())
        section = offering.getSection(assignment.getClassId())
        writer.writerow([
            student.getExternalId(), student.getName(),
            course.getCourseName(), section.getExternalId(assignment.getCourseId()),
            'Failed', message
            ])

def executeAction(server, action, student, writer):
    if not action: return False
    enrollment = None
    try:
        enrollment = server.execute(action, getUser(student))
    except SectioningException, e:
        log.error('Enrollment failed: %s' % e.getMessage())
        failStudent(server, action, student, writer, e.getMessage())
        # writer.writerow([ student.getExternalId(), student.getName(), None, None, 'Failed', e.getMessage() ])
        return False
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        sections = HashSet()
        for clazz in course.getClassAssignments():
            if not sections.add(clazz.getSection()): continue
            line = [ student.getExternalId(), student.getName(), '%s %s' % (course.getSubject(), course.getCourseNbr()), clazz.getSection() ]
            if clazz.isSaved(): line.append('Enrolled')
            else: line.append('Not Enrolled')
            if clazz.hasError():
                line.append(clazz.getError())
            if clazz.hasError():
                log.warn('%s %s %s: %s (%s)' % (course.getSubject(), course.getCourseNbr(), clazz.getSection(), clazz.getError(), line[5]))
            else:
                log.debug('%s %s %s' % (course.getSubject(), course.getCourseNbr(), clazz.getSection()))
            writer.writerow(line)
    return True

def execute(batch, online):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Status','Message'])
    failed = ArrayList()
    for student in getStudents(batch):
        if not executeAction(online, generateAction(batch, student), student, writer):
            failed.add(Long(student.getStudentId()))
    writer.writerow(['EOF'])
    file.close()
    if failed.size() > 0:
        req = RequestStudentUpdates()
        req.forStudents(failed)
        online.execute(req, getUser(None))

batch = getBatchServer()
online = getOnlineServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
elif batch.isRunning():
    log.error("Batch student scheduling solver is running.")
elif batch.isWorking():
    log.error("Batch student scheduling solver is working.")
elif not online:
    log.error("Online student scheduling solver is not running.")
else:
    execute(batch, online)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Export" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 15:06:03 EDT 2016">
  <description><![CDATA[<h3>Export batch student scheduling solver student class enrollments data into a CSV file</h3>
<b>Format:</b><ul>
<li>There is a line for each student
<li>PUID, Name, CRN1, CRN2, .... 
</ul>
<b>Parameters:</b><ul>
<li>Add Leading Zeros: add leading zeros to the PUID
</ul>]]></description>
  <parameter name="zeros" label="Add Leading Zeros" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import UserData
from org.unitime.timetable.model.dao import Class_DAO, CourseOfferingDAO
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher
from org.unitime.timetable.onlinesectioning.model import XCourseRequest

def getServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def generateRow(server, student):
    puid = student.getExternalId()
    if zeros: puid = puid.zfill(9)
    name = student.getName()
    log.info("%s %s" % (puid, name))
    line = [puid, name]
    crns = {}
    for req in server.getStudent(student.getStudentId()).getRequests():
        if not isinstance(req, XCourseRequest): continue
        enrl = req.getEnrollment()
        if not enrl: continue
        course = hibSession.createQuery("from CourseOffering where uniqueId = :id").setLong("id", enrl.getCourseId()).uniqueResult()
        for id in enrl.getSectionIds():
            clazz = hibSession.createQuery("from Class_ where uniqueId = :id").setLong("id", id).uniqueResult()
            crns[clazz.getExternalId(course)] = True
    line.extend(sorted(crns.keys()))
    log.debug('-- %s' % ','.join(sorted(crns.keys())))
    return line

def execute(server):
    file = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN','CRN'])
    for student in getStudents(server):
        writer.writerow(generateRow(server, student))
    writer.writerow(['EOF'])
    file.close()

server = getServer()
if not server:
    log.error("Batch student scheduling solver is not loaded in.")
elif server.isRunning():
    log.error("Batch student scheduling solver is running.")
elif server.isWorking():
    log.error("Batch student scheduling solver is working.")
else:
    execute(server)]]></body>
</script>
<script name="Batch Student Scheduling: Solver Enroll [XE]" permission="Student Sectioning Solver" engine="python" created="Thu Jun 02 13:47:53 EDT 2016">
  <description><![CDATA[<h3>Enroll students from the batch studeht scheduling solver using the Banner XE API.</h3>
<p>Output is returned in the CSV format.<br>There is a line for each student class enrollment:<br>PUID, Name, Course, CRN, Request, Registration Status, Error Message, Used Override</p>
<p><b>Parameters:</b><ul>
<li>Name Columns: number of columns with student name
<li>Automatic Overrides: check to use automatic overrides
<li>Allowed Overrides: list of overrides that can be used (when enabled)
<li>Manual Overrides: list of overrides that are manually put in
<li>Conditional Add Drop: check if conditional add drop is to be enabled
<li>Hold Password: enter hold password if students with hold should be enrolled
<li>Registration Date: for back-dating enter registration date (in yyyy-mm-dd format)
</ul></p>]]></description>
  <parameter name="autoOverrides" label="1. Automatic Overrides" type="boolean" default="false"/>
  <parameter name="ovCampus" label="2a. Allow Override CAMPUS" type="boolean" default="true"/>
  <parameter name="ovClass" label="2b. Allow Override CLASS" type="boolean" default="true"/>
  <parameter name="ovClosed" label="2c. Allow Override CLOSED" type="boolean" default="false"/>
  <parameter name="ovCoReq" label="2d. Allow Override CO-REQ" type="boolean" default="true"/>
  <parameter name="ovCollege" label="2e. Allow Override COLLEGE" type="boolean" default="true"/>
  <parameter name="ovDegree" label="2f. Allow Override DEGREE" type="boolean" default="true"/>
  <parameter name="ovDptPermit" label="2g. Allow Override DPT-PERMIT" type="boolean" default="true"/>
  <parameter name="ovDupCrse" label="2h. Allow Override DUP-CRSE" type="boolean" default="true"/>
  <parameter name="ovHonors" label="2i. Allow Override HONORS" type="boolean" default="true"/>
  <parameter name="ovInstPermit" label="2j. Allow Override INST-PERMIT" type="boolean" default="true"/>
  <parameter name="ovLevel" label="2k. Allow Override LEVEL" type="boolean" default="true"/>
  <parameter name="ovMajor" label="2l. Allow Override MAJOR" type="boolean" default="true"/>
  <parameter name="ovPreReq" label="2m. Allow Override PRE-REQ" type="boolean" default="false"/>
  <parameter name="ovProgram" label="2n. Allow Override PROGRAM" type="boolean" default="true"/>
  <parameter name="ovTimeCnflt" label="2o. Allow Override TIME-CNFLT" type="boolean" default="false"/>
  <parameter name="overrides" label="3. Manual Overrides" type="textarea" default="PUID,CRN,Override (one override per line)"/>
  <parameter name="conditionalAddDrop" label="4. Conditional Add Drop" type="boolean" default="true"/>
  <parameter name="holdPassword" label="5. Hold Password" type="text"/>
  <parameter name="registrationDate" label="6. Registration Date (yyyy-mm-dd)" type="text"/>
  <parameter name="actionAdd" label="7a. Registration Status ADD" type="enum(RE,RW)" default="RE"/>
  <parameter name="actionDrop" label="7b. Registration Status DROP" type="enum(DD,DW,DDD,CA)" default="DDD"/>
  <body><![CDATA[import csv
from xml.dom import minidom
from java.lang import Long
from java.util import ArrayList, HashSet, Date
from java.io import StringReader
from org.dom4j.io import SAXReader
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable import ApplicationProperties
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.banner.model import BannerSession, QueueOut
from org.unitime.timetable.spring import SpringApplicationContextHolder
from org.unitime.timetable.onlinesectioning import OnlineSectioningLog
from org.unitime.timetable.onlinesectioning.basic import GetAssignment
from org.unitime.timetable.onlinesectioning.match import AnyStudentMatcher

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getCourseNameForCrn(crn):
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()
    if course:
        return course.getCourseName()
    return None

def getConsent(crn):
    return hibSession.createQuery(
        "select co.consentType.reference from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId"
        ).setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()

def getDefaultOverride(crn, messageType):
    if messageType == 'DEPT' or messageType == 'SAPR':
        consent = getConsent(crn)
        if consent == "IN": return "INST-PERMT"
        elif consent == "DP": return "DPT-PERMIT"
        else: return "HONORS"
    elif messageType in defaultOverrides:
        return defaultOverrides[messageType]
    else:
        return None

def getManualOverride(puid, crn, manualOverrides):
    if not manualOverrides: return None
    for line in manualOverrides:
        if not line: continue
        if not line[0] or line[0].strip().zfill(9) == puid:
            if line[1] and line[1].strip() == crn:
                return line[2].strip()
    return None

def addOverride(req, id, override, overrides):
    for crn in req.courseReferenceNumbers:
        if crn.courseReferenceNumber == id:
            log.debug('Adding override %s for %s' % (override, id))
            crn.courseOverride = override
            if id not in overrides:
                overrides[id] = [override]
            else:
                overrides[id].append(override)
            return True
    log.warn('Failed to add override %s for %s' % (override, id))
    return False

def getOverride(req, id, overrides):
    if overrides and id in overrides:
        return ','.join(overrides[id])
    elif req.courseReferenceNumbers:
        for crn in req.courseReferenceNumbers:
            if crn.courseReferenceNumber == id:
                return crn.courseOverride
    return None

def handleError(resource, e):
    error = None
    if resource.getResponseEntity():
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        if response: error = response.getError()
    if error and error.message:
        raise SectioningException(error.message)
    if error and error.description:
        raise SectioningException(error.description)
    if error and error.errorMessage:
        raise SectioningException(error.errorMessage)
    raise SectioningException(e.getMessage())

def getSchedule(resource):
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e: handleError(resource, e)

    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)

    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if m == "Holds prevent registration." and holdPassword:
                    return getHoldSchedule(resource)
                if m == "Invalid or undefined Enrollment Status or date range invalid." and registrationDate:
                    return getHoldSchedule(resource)
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return original

def getHoldSchedule(resource):
    if holdPassword:
        log.debug("Using hold password...")
    elif registrationDate:
        log.debug("Using registration date...")
    term = resource.getQueryValue("term")
    puid = resource.getQueryValue("bannerId")
    req = XEInterface.RegisterRequest(term, puid, None, True)
    req.empty()
    if holdPassword:
        req.holdPassword = holdPassword
    if registrationDate:
        req.registrationDate = registrationDate

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()

    if not response:
        raise SectioningException("Failed to check student registration status.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return response

def postChanges(resource, req):
    if req.isEmpty(): req.empty()

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()

    if not response:
        raise SectioningException("Failed to enroll student.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to enroll student.")

    return response

def isAllowedOverride(override):
    if override == 'CAMPUS': return ovCampus
    if override == 'CLASS': return ovClass
    if override == 'CLOSED': return ovClosed
    if override == 'COLLEGE': return ovCollege
    if override == 'CO-REQ': return ovCoReq
    if override == 'DEGREE': return ovDegree
    if override == 'DPT-PERMIT': return ovDptPermit
    if override == 'INST-PERMT': return ovInstPermit
    if override == 'HONORS': return ovHonors
    if override == 'DUP-CRSE': return ovDupCrse
    if override == 'LEVEL': return ovLevel
    if override == 'MAJOR': return ovMajor
    if override == 'PRE-REQ': return ovPreReq
    if override == 'PROGRAM': return ovProgram
    if override == 'TIME-CNFLT': return ovTimeCnflt
    return False

def add(req, id, changeStatus):
    if not actionAdd:
        req.add(id, changeStatus)
    elif changeStatus:
        if not req.actionsAndOptions: req.actionsAndOptions = ArrayList()
        req.actionsAndOptions.add(XEInterface.RegisterAction(actionAdd, id))
    else:
        if not req.courseReferenceNumbers: req.courseReferenceNumbers = ArrayList()
        req.courseReferenceNumbers.add(XEInterface.CourseReferenceNumber(id, actionAdd))

def keep(req, id):
    req.keep(id)

def drop(req, id):
    if not actionDrop:
        req.drop(id)
    else:
        if not req.actionsAndOptions: req.actionsAndOptions = ArrayList()
        req.actionsAndOptions.add(XEInterface.RegisterAction(actionDrop, id))

def enroll(client, puid, name, crns, writer, manualOverrides):
    log.info('%s: %s [%s]' % (puid, name, ','.join(crns)))
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    puid = puid.zfill(9)

    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", puid)
    resource.addQueryParameter("systemIn", "SB")
    resource.addQueryParameter("persona", "SB")
    if holdPassword:
        resource.addQueryParameter("holdPassword", holdPassword)

    original = getSchedule(resource)

    noadd = HashSet()
    nodrop = HashSet()
    notregistered = HashSet()
    registered = {}
    if original.registrations:
        for reg in original.registrations:
            if reg.isRegistered():
                registered[reg.courseReferenceNumber] = reg
                if not reg.can(actionDrop):
                    nodrop.add(reg.courseReferenceNumber)
            else:
                notregistered.add(reg.courseReferenceNumber)
                if not reg.can(actionAdd):
                    noadd.add(reg.courseReferenceNumber)

    added = HashSet()
    req = XEInterface.RegisterRequest(term, puid, None, True)
    if holdPassword:
        req.holdPassword = holdPassword
    for id in crns:
        if not id: continue
        if not id in registered and noadd.contains(id):
            writer.writerow([
                puid, name,
                getCourseNameForCrn(id), id,
                'Failed', 'Action %s is not allowed.' % actionAdd
            ])
        else:
            if id in registered:
                if added.add(id): keep(req, id)
            else:
                if added.add(id): add(req, id, notregistered.contains(id))
    for id in registered.keys():
        if added.contains(id): continue
        reg = registered[id]
        if not campus == reg.campus:
            if added.add(id): keep(req, id)
        elif nodrop.contains(id):
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                'Failed', 'Action %s is not allowed.' % actionDrop
            ])
            if added.add(id): keep(req, id)
        else:
            drop(req, id)

    appliedOverrides = {}
    for id in crns:
        override = getManualOverride(puid, id, manualOverrides)
        if override: addOverride(req, id, override, appliedOverrides)

    if registrationDate:
        req.registrationDate = registrationDate
    if conditionalAddDrop:
        req.conditionalAddDrop = "Y"

    response = postChanges(resource, req)

    while autoOverrides and response.registrations:
        changed = False
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            if reg.crnErrors:
                for e in reg.crnErrors:
                    override = getDefaultOverride(id, e.messageType)
                    if override and isAllowedOverride(override):
                        if addOverride(req, id, override, appliedOverrides):
                            changed = True
                        break

        if not changed: break
        response = postChanges(resource, req)

    checked = HashSet()
    if response.registrations:
        for reg in response.registrations:
            id = reg.courseReferenceNumber
            checked.add(id)
            op = None
            if added.contains(id):
                op = "Add"
            else:
                op = "Drop"
                if id in notregistered: continue
            error = None
            errorType = []
            if reg.crnErrors:
                for e in reg.crnErrors:
                    if not error:
                        error = '%s: %s' % (e.messageType, e.message)
                    else:
                        error = "%s\n%s: %s" % (error, e.messageType, e.message)
            writer.writerow([
                puid, name,
                '%s %s' % (reg.subject, reg.courseNumber), id,
                op, reg.statusDescription, error, getOverride(req, id, appliedOverrides)
            ])
            if error: log.warn('%s: %s' % (id, error))

    if response.failedRegistrations:
        for reg in response.failedRegistrations:
            if not reg.failedCRN or not reg.failure: continue
            id = reg.failedCRN
            checked.add(id)
            op = None
            if added.contains(id): op = "Add"
            else: op = "Drop"
            error = reg.failure
            writer.writerow([
                puid, name,
                getCourseNameForCrn(id), id,
                op, 'Failed', error, getOverride(req, id, appliedOverrides)
            ])
            log.warn('%s: %s' % (id, error))

    ex = False
    for id in crns:
        if not id: continue
        if checked.contains(id): continue
        op = None
        if added.contains(id): op = "Add"
        else: op = "Drop"
        ex = True
        writer.writerow([
            puid, name,
            getCourseNameForCrn(id), id,
            op, 'Exception', response.registrationException])

    if response.registrationException and not ex:
        writer.writerow([
            puid, name,
            None, None,
            None, 'Exception', response.registrationException])

    if response.registrationException: log.warn(response.registrationException)

    resource.release()

def failStudent(puid, name, crns, writer, message):
    for id in crns:
        if not id: continue
        writer.writerow([puid, name, getCourseNameForCrn(id), id, 'Add', 'Failed', message])

def createStudentRequestUpdateMessage(puids):
    term = BannerTermProvider().getExternalTerm(AcademicSessionInfo(session))
    doc = minidom.getDOMImplementation().createDocument(None, "studentUpdateRequest", None)
    root = doc.documentElement
    for puid in puids:
        studentEl = doc.createElement("student")
        studentEl.setAttribute("externalId", puid.zfill(9))
        studentEl.setAttribute("session", term)
        root.appendChild(studentEl)
    return doc.toprettyxml()

def requestStudentUpdate(puids):
    log.info('Requesting student update...')
    message = createStudentRequestUpdateMessage(puids)
    out = QueueOut()
    out.setXml(SAXReader().read(StringReader(message)))
    out.setStatus(QueueOut.STATUS_READY)
    out.setPostDate(Date())
    hibSession.save(out)

defaultOverrides = {
    'CAMP': 'CAMPUS',
    'CLAS': 'CLASS',
    'CLOS': 'CLOSED',
    'COLL': 'COLLEGE',
    'CORQ': 'CO-REQ',
    'DEGR': 'DEGREE',
    'DEPT': 'DPT-PERMIT',
    'DUPL': 'DUP-CRSE',
    'LEVL': 'LEVEL',
    'MAJR': 'MAJOR',
    'PREQ': 'PRE-REQ',
    'PROG': 'PROGRAM',
    'TIME': 'TIME-CNFLT',
    }

def getBatchServer():
    service = SpringApplicationContextHolder.getBean("solverServerService")
    container = service.getStudentSolverContainer()
    server = container.getSolver(log.getOwnerId())
    return server

def getUser():
    user = OnlineSectioningLog.Entity.newBuilder()
    user.setExternalId(log.getOwnerId())
    user.setName(log.getOwnerName())
    user.setType(OnlineSectioningLog.Entity.EntityType.MANAGER)
    return user.build()

def getCrn(course, assignment):
    crns = hibSession.createQuery(
        "select bsc.bannerSection.crn from BannerSectionToClass as bsc where bsc.bannerSection.bannerConfig.bannerCourse.courseOfferingId = :courseId and bsc.classId = :classId"
        ).setLong("classId", assignment.getClassId()).setLong("courseId", course.getCourseId()).setCacheable(True).list()
    if crns: return str(crns[0])
    log.error('Failed to lookup CRN for: %s %s' % (course.getCourseName(), assignment.getSection()))
    return assignment.getSection()

def getCrns(server, studentId):
    enrollment = server.execute(GetAssignment().forStudent(studentId), getUser())
    crns = {}
    for course in enrollment.getCourseAssignments():
        if course.isFreeTime(): continue
        for assignment in course.getClassAssignments():
            id = getCrn(course, assignment)
            if id: crns[id] = True
    return sorted(crns.keys())

def getStudents(server):
    m = AnyStudentMatcher()
    m.setServer(server)
    return server.findStudents(m)

def execute(batch):
    manualOverrides = None
    if overrides:
        manualOverrides = csv.reader(overrides.split('\n'), delimiter=",", quotechar='"')
    output = open(log.createOutput('enrollments','csv').getAbsolutePath(), 'w')
    writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['PUID','Name','Course','CRN','Request','Status','Message','Used Override'])
    client = getClient()
    puids = []
    students = getStudents(batch)
    log.setStatus('Enrolling students', students.size())
    for student in students:
        puid = student.getExternalId()
        name = student.getName()
        crns = getCrns(batch, student.getStudentId())
        puids.append(puid)
        try:
            enroll(client, puid, name, crns, writer, manualOverrides)
        except SectioningException, e:
            log.error('Enrollment failed: %s' % e.getMessage())
            failStudent(puid, name, crns, writer, e.getMessage())
        log.incProgress()
    writer.writerow(['EOF'])
    output.close()
    client.stop()
    if puids:
        requestStudentUpdate(puids)

batch = getBatchServer()
if not batch:
    log.error("Batch student scheduling solver is not loaded in.")
else:
    execute(batch)
]]></body>
</script>
<script name="Batch Student Scheduling: Undo Data Import" permission="Student Sectioning Solver" engine="python" created="Tue May 31 10:19:49 EDT 2016">
  <description><![CDATA[Remove all course requests that the students of the given student group are not enrolled in.]]></description>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)"/>
  <body><![CDATA[from org.unitime.timetable.model import StudentSectioningQueue
from java.util import HashSet, ArrayList
from java.lang import Long
    
def execute():
    studentIds = HashSet()
    for student in hibSession.createQuery(
        "from Student where session = :sessionId and sectioningStatus.reference = :status"
        ).setLong('sessionId', session.getUniqueId()).setString('status', statusRef).list():
        log.info(student.getName('last-first-middle'))
        changed = False
        for cd in ArrayList(student.getCourseDemands()):
            enrolled = False
            for cr in cd.getCourseRequests():
                log.debug('-- checking %s' % cr.getCourseOffering().getCourseName())
                for enrl in student.getClassEnrollments():
                    if enrl.getCourseOffering() == cr.getCourseOffering(): enrolled = True
            if not enrolled:
                for cr in cd.getCourseRequests():
                    log.debug('-- removing %s' % cr.getCourseOffering().getCourseName())
                    hibSession.delete(cr)
                student.getCourseDemands().remove(cd)
                hibSession.delete(cd)
                changed = True
        if changed:
            hibSession.update(student)
            studentIds.add(Long(student.getUniqueId()))

    if studentIds.size() > 0:
        StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), studentIds)
    
if not statusRef:
    log.error("A student status must be selected.")
else:
    execute()]]></body>
</script>
</scripts>
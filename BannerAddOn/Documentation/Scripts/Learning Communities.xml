<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE scripts PUBLIC "-//UniTime//DTD University Course Timetabling/EN" "http://www.unitime.org/interface/Script.dtd">

<!--
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 -->

<scripts created="March 14, 2016">
<script name="Learning Communities: Course Matrix Import [legacy]" permission="Student Group Edit" engine="python" created="Mon Mar 14 11:28:15 EDT 2016">
  <description><![CDATA[This script creates student groups and student group reservations according to the input file (LC Course Matrix in CSV format).]]></description>
  <parameter name="file" label="Input File" type="file"/>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <body><![CDATA[import csv
import re
from org.unitime.timetable.model import StudentGroup, LearningCommunityReservation, StudentSectioningQueue, StudentGroupType
from java.util import HashSet
from java.lang import Long

def getGroupCode(name):
    m = re.search('(.+) - (.+)', name)
    if m:
        return m.group(1)
    m = re.search('(.+) \(.+\)', name)
    if m: name = m.group(1)             
    code = []
    for word in name.split(' '):
        if not word: continue
        if word in ["to", "in", "of", "for", "the", "a", "&", "-", "or", "and"]: continue
        m = re.search('([A-Z][A-Z]+)', word)
        if m:
            if len(code) > 0: code.append(' ')
            code.extend(m.group(1))
            code.append(' ')
        elif len(word) <= 4:
            code.extend(word)
        else:
            code.extend(word[0:3])
    return ''.join(code).strip() 

def getGroupName(name):
    m = re.search('(.+) - (.+)', name)
    if m:
        return m.group(2)
    return name
    
def getGroup(name):
    group = hibSession.createQuery("from StudentGroup where groupName = :name and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("name", getGroupName(name)).setMaxResults(1).uniqueResult();
    if not group:
        log.info("Creating group for name %s" % name)
        group = StudentGroup()
        group.setSession(session)
        group.setGroupAbbreviation(getGroupCode(name));
        group.setGroupName(getGroupName(name));
        group.setUniqueId(hibSession.save(group))
        group.setType(StudentGroupType.findByReference(groupTypeRef, hibSession))
    return group

def addClass(course2classes, group, subject, courseNbr, crn, title):
    clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    if clazz and course:
        log.debug(clazz.getClassLabelWithTitle(course))
        classes = None
        if course in course2classes:
            classes = course2classes[course]
        else:
            classes = []
            course2classes[course] = classes
        classes.append(clazz)
    else:
        log.error("Class %s %s %d not found." % (subject, courseNbr, crn))
        
def isParent(c1, c2):
    if c2.getParentClass():
        if c1 == c2.getParentClass(): return True
        return isParent(c1, c2.getParentClass())
    return False

def hasChild(clazz, classes):
    for c in classes:
        if isParent(clazz, c): return True
    return False

def createReservations(offerings, group, course2classes):
    for course in course2classes.keys():
        log.info("Checking reservation for %s..." % course.getCourseName())
        reservation = hibSession.createQuery("from LearningCommunityReservation where instructionalOffering = :offeringId and group = :groupId").setLong("offeringId", course.getInstructionalOffering().getUniqueId()).setLong("groupId", group.getUniqueId()).uniqueResult()
        if not reservation:
            reservation = LearningCommunityReservation()
            reservation.setGroup(group)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setCourse(course)
            reservation.setLimit(0)
        else:
            reservation.getClasses().clear()
        classes = course2classes[course]
        for clazz in classes:
            if not hasChild(clazz, classes):
                reservation.getClasses().add(clazz)
                log.debug("add %s" % clazz.getClassLabel(course))
            else:
                log.debug("skip %s" % clazz.getClassLabel(course))
        offerings.add(Long(course.getInstructionalOffering().getUniqueId()))
        hibSession.saveOrUpdate(reservation)

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')

group = None
header = True
course2classes = None
offerings = HashSet()
for line in lines:
    if not line or not line[2]:
        if group: createReservations(offerings, group, course2classes)
        group = None
        continue
    if header:
        header = False
        if "Learning Community" == line[0]: continue
    if not group and line[0]:
        group = getGroup(line[0])
        course2classes = {}
        print "Group %s - %s" % (group.getGroupAbbreviation(), group.getGroupName())
    if line[2] and line[3] and line[4]:
        subject = line[3].strip()
        courseNbr = line[4].strip()
        title = line[5]
        for extId in line[2].split(';'):
            addClass(course2classes, group, subject, courseNbr, int(extId.strip()), title)
if group: createReservations(offerings, group, course2classes)
if offerings:    
    StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offerings);]]></body>
</script>
<script name="Learning Communities: Course Matrix Import [simplified]" permission="Student Group Edit" engine="python" created="Wed Apr 12 08:30:27 EDT 2017">
  <description><![CDATA[This script creates student groups and student group reservations according to the CSV input file  in one of the following formats:<ol><li>One line per class:<pre>
LC, Name   , Size, Subj, Course, CRN
G1, Group 1, 24  , ENGL, 10600 , 12345
  ,        ,     ,     ,       , 12346
  ,        ,     , BIOL, 10100 , 22222
G2, Group 2, 26  , ENGL, 10600 , 12345
  ,        ,     ,     ,       , 12347
  ,        ,     , MATH, 20100 , 12034
</pre></li><li>One line per course:<pre>
LC, Name   , Size, Subj, Course, CRN1 , CRN2 , CRN3 , ...
G1, Group 1, 24  , ENGL, 10600 , 12345, 12346
  ,        ,     , BIOL, 10100 , 22222
G2, Group 2, 26  , ENGL, 10600 , 12345, 12347
  ,        ,     , MATH, 20100 , 12034
</pre></li><li>One line per course, no section-level restrictions:<pre>
LC, Name   , Size, Subj, Course
G1, Group 1, 24  , ENGL, 10600R
  ,        ,     , BIOL, 10100
G2, Group 2, 26  , ENGL, 10600R
  ,        ,     , MATH, 20100
</pre></li></ol>Size column is optional.]]></description>
  <parameter name="file" label="Input File" type="file"/>
  <parameter name="expirationDate" label="Reservation Expiration Date (yyyy-mm-dd)" type="text"/>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import StudentGroup, LearningCommunityReservation, StudentSectioningQueue, StudentGroupType
from java.util import HashSet
from java.lang import Long
from java.text import SimpleDateFormat

def getGroup(abbv, name, size):
    group = hibSession.createQuery("from StudentGroup where groupAbbreviation = :abbv and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("abbv", abbv).setMaxResults(1).uniqueResult();
    if not group:
        log.info("Creating group %s - %s" % (abbv, name))
        group = StudentGroup()
        group.setSession(session)
        group.setGroupAbbreviation(abbv);
        group.setGroupName(name);
        group.setUniqueId(hibSession.save(group))
        group.setType(StudentGroupType.findByReference(groupTypeRef, hibSession))
    else:
        log.info("Found group %s - %s" % (group.getGroupAbbreviation(), group.getGroupName()))
    return group

def addClass(course2classes, course2limit, group, subject, courseNbr, crn, limit, writer):
    clazz = hibSession.createQuery("select c from BannerSection bs inner join bs.bannerSectionToClasses as bstc, Class_ c where bs.session = :sessionId and bs.crn = :crn and bstc.classId = c.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setInteger("crn", crn).setMaxResults(1).uniqueResult()
    if clazz and course:
        if not course.getSubjectAreaAbbv() == subject or not course.getCourseNbr().startswith(courseNbr):
            log.error("Class %s %s %d is wrong (found %s)." % (subject, courseNbr, crn, course.getCourseNameWithTitle()))
            writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn, "Class %s %s %d is wrong (found %s)." % (subject, courseNbr, crn, course.getCourseNameWithTitle())])
            return
        log.debug(clazz.getClassLabelWithTitle(course))
        classes = None
        if limit and not course in course2limit: course2limit[course] = limit
        if course in course2classes:
            classes = course2classes[course]
        else:
            classes = []
            course2classes[course] = classes
        classes.append(clazz)
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn])
    else:
        log.error("Class %s %s %d not found." % (subject, courseNbr, crn))
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, crn, "Class %s %s %d not found." % (subject, courseNbr, crn)])

def addCourse(course2classes, course2limit, group, subject, courseNbr, limit, writer):
    course = hibSession.createQuery("from CourseOffering co where co.subjectArea.session = :sessionId and co.subjectAreaAbbv = :subject and co.courseNbr = :courseNbr"
                                    ).setLong("sessionId", session.getUniqueId()).setString("subject", subject).setString("courseNbr", courseNbr).setMaxResults(1).uniqueResult()
    if course:
        log.debug(course.getCourseNameWithTitle())
        if course not in course2classes:
            course2classes[course] = []
        if limit and not course in course2limit: course2limit[course] = limit
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, None])
    else:
        log.error("Course %s %s not found." % (subject, courseNbr))
        writer.writerow([group.getGroupAbbreviation(), group.getGroupName(), subject, courseNbr, None, "Course %s %s not found." % (subject, courseNbr)])
        
def isParent(c1, c2):
    if c2.getParentClass():
        if c1 == c2.getParentClass(): return True
        return isParent(c1, c2.getParentClass())
    return False

def hasChild(clazz, classes):
    for c in classes:
        if isParent(clazz, c): return True
    return False

def createReservations(offerings, group, course2classes, course2limit):
    reservations = {}
    for r in hibSession.createQuery("from LearningCommunityReservation where group = :groupId").setLong("groupId", group.getUniqueId()).list():
        reservations[r.getInstructionalOffering().getUniqueId()] = r
    for course in course2classes.keys():
        reservation = None
        if course.getInstructionalOffering().getUniqueId() in reservations:
            log.info("Checking reservation for %s (%s)..." % (course.getCourseName(), group.getGroupAbbreviation()))
            reservation = reservations.pop(course.getInstructionalOffering().getUniqueId())
            reservation.getClasses().clear()
        else:
            log.info("Creating reservation for %s (%s)..." % (course.getCourseName(), group.getGroupAbbreviation()))
            reservation = LearningCommunityReservation()
            reservation.setGroup(group)
            reservation.setInstructionalOffering(course.getInstructionalOffering())
            reservation.setClasses(HashSet())
            reservation.setCourse(course)
            reservation.getInstructionalOffering().getReservations().add(reservation)
        if expirationDate:
            reservation.setExpirationDate(SimpleDateFormat("y-M-d").parse(expirationDate))
        else:
            reservation.setExpirationDate(None)
        classes = course2classes[course]
        for clazz in classes:
            if not hasChild(clazz, classes):
                reservation.getClasses().add(clazz)
                log.debug("add %s" % clazz.getClassLabel(course))
            else:
                log.debug("skip %s" % clazz.getClassLabel(course))
        if course in course2limit:
            reservation.setLimit(course2limit[course])
        else:
            reservation.setLimit(0)
        hibSession.saveOrUpdate(reservation)
        offerings.add(Long(course.getInstructionalOffering().getUniqueId()))
    for r in reservations.values():
        log.info("Deleting reservation for %s (%s)..." % (r.getInstructionalOffering().getCourseName(), group.getGroupAbbreviation()))
        r.getInstructionalOffering().getReservations().remove(r)
        offerings.add(Long(r.getInstructionalOffering().getUniqueId()))
        hibSession.delete(r)
    hibSession.flush()

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')
output = open(log.createOutput('lc-import-results','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','Name','Subject','Course','CRN','Error'])

groups = {}
header = True
course2classes = {}
course2limit = {}
last = [None, None, None, None, None]

colAbbv = 0
colName = 1
colSize = None
colSubject = 2
colCourse = 3
colCrns = 4

for line in lines:
    if not line:
        last = [None, None, None, None, None]
        continue
    
    lcAbbv = line[colAbbv].strip()
    lcName = line[colName].strip()
    lcSize = None
    if colSize:
        try:
            lcSize = int(line[colSize].strip())
        except:
            if line[colSize].strip():
                log.warn('Wrong group size %s.' % line[colSize].strip())
    subject = line[colSubject].strip()
    courseNbr = line[colCourse].strip()
    crns = []
    for crn in line[colCrns:]:
        if crn.strip(): crns.append(crn.strip())
    if header:
        header = False
        if "LC" == lcAbbv:
            if "size" == subject.lower() or "limit" == subject.lower():
                log.debug('Size column is included.')
                colSize = 2
                colSubject = 3
                colCourse = 4
                colCrns = 5
            continue
    if not lcAbbv: lcAbbv = last[0]
    elif last[0] and last[0] != lcAbbv:
        last = [None, None, None, None, None]
    if not lcName: lcName = last[1]
    if not subject: subject = last[2]
    if not courseNbr: courseNbr = last[3]
    if not lcSize: lcSize = last[4]
    last = [lcAbbv, lcName, subject, courseNbr, lcSize]
    
    if lcAbbv not in groups:
        groups[lcAbbv] = getGroup(lcAbbv, lcName, lcSize)
        course2classes[lcAbbv] = {}
        course2limit[lcAbbv] = {}
    
    if crns:
        for crn in crns:
            addClass(course2classes[lcAbbv], course2limit[lcAbbv], groups[lcAbbv], subject, courseNbr, int(crn), lcSize, writer)
    else:
        addCourse(course2classes[lcAbbv], course2limit[lcAbbv], groups[lcAbbv], subject, courseNbr, lcSize, writer)
writer.writerow(['EOF'])
output.close()

offerings = HashSet()
for lcAbbv in groups.keys():
    createReservations(offerings, groups[lcAbbv], course2classes[lcAbbv], course2limit[lcAbbv])

if offerings:    
    StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offerings);]]></body>
</script>
<script name="Learning Communities: Student Import" permission="Student Group Edit" engine="python" created="Tue Apr 18 11:46:42 EDT 2017">
  <description><![CDATA[This script imports students of one or more student groups according to the input CSV file in the following formats:
<ol><li>One line per student:<pre>
LC, PUID
G1, 752297072
  , 670857846
  , 110163506
  , 685497415
G2, 565607184
  , 288674378
  , 845738199
  , 139074464
</pre></li><li>One line per group:<pre>
LC, PUID1    , PUID2    , PUID3    , ...
G1, 752297072, 670857846, 110163506, 685497415
G2, 565607184, 288674378, 845738199, 139074464
</pre></li></ol>]]></description>
  <parameter name="updateSpace" label="Update Reserved Space" type="boolean" default="true"/>
  <parameter name="file" label="Input File" type="file"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)" default="LC"/>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <parameter name="canCreateGroup" label="Create Groups" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import StudentSectioningQueue, StudentSectioningStatus, StudentGroup, StudentGroupType
from java.util import HashSet
from java.lang import Long

def lookupStudent(puid):
    student = hibSession.createQuery("from Student where session = :sessionId and externalUniqueId = :puid").setLong("sessionId", session.getUniqueId()).setString("puid", puid).setMaxResults(1).uniqueResult()
    if not student:
        log.warn("Student %s not found." % puid)
    else:
        log.debug("%s (%s)" % (student.getName("last-first-middle"), puid))
    return student

def enroll(students, lcAbbv, puids, status, writer):
    group = hibSession.createQuery("from StudentGroup where (groupAbbreviation = :abbv or groupName = :abbv) and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("abbv", lcAbbv).setMaxResults(1).uniqueResult();
    if not group and canCreateGroup:
        group = StudentGroup()
        group.setGroupAbbreviation(lcAbbv)
        group.setGroupName(lcAbbv)
        group.setSession(session)
        group.setStudents(HashSet())
        group.setType(StudentGroupType.findByReference(groupTypeRef, hibSession))
        hibSession.saveOrUpdate(group) 
    if not group:
        log.error("Student group %s does not exist." % lcAbbv)
        for puid in puids:
            student = lookupStudent(puid.lstrip("0"))
            if student:
                writer.writerow([lcAbbv, puid, student.getName("last-first-middle"), student.getEmail(), "Student group %s does not exist." % lcAbbv])
            else:
                writer.writerow([lcAbbv, puid, None, None, "Student group %s does not exist.\nStudent %s not found." % (lcAbbv, puid)])
        return
    log.info("%s - %s" % (group.getGroupAbbreviation(), group.getGroupName()))
    group.getStudents().clear()
    for puid in puids:
        student = lookupStudent(puid.lstrip("0"))
        if student:
            group.getStudents().add(student)
            students.add(Long(student.getUniqueId()))
            writer.writerow([group.getGroupAbbreviation(), puid, student.getName("last-first-middle"), student.getEmail()])
            if status:
                student.setSectioningStatus(status)
                hibSession.saveOrUpdate(student)
        else:
            writer.writerow([group.getGroupAbbreviation(), puid, None, None, "Student %s not found." % puid])
    hibSession.saveOrUpdate(group)
    if updateSpace:
        for r in hibSession.createQuery("from LearningCommunityReservation where group = :groupId").setLong("groupId", group.getUniqueId()).list():
            r.setLimit(len(puids))
            hibSession.saveOrUpdate(r)

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')

status = None
if statusRef:
    status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)

groups = {}
header = True
last = None
students = HashSet()
for line in lines:
    if not line:
        last = None
        continue
    
    lc = line[0].strip()
    if header:
        header = False
        if "LC" == lc: continue
    
    if not lc: lc = last
    last = lc
    if lc not in groups: groups[lc] = []
    for puid in line[1:]:
        if puid.strip(): groups[lc].append(puid.strip())

output = open(log.createOutput('lc-enrollment-results','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','PUID','Name','Email','Error'])
for lc in groups.keys():
    enroll(students, lc, groups[lc], status, writer)
writer.writerow(['EOF'])
output.close()

if students:
    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), students)]]></body>
</script>
<script name="Learning Communities: Create Course Demands" permission="Student Group Edit" engine="python" created="Tue Apr 18 11:46:36 EDT 2017">
  <description><![CDATA[<p style='max-width:800px'>This script makes sure that students which are enrolled into the existing student groups (of given type) also request the appropriate courses. The script is using the existing learning community reservations.</p>]]></description>
  <parameter name="clear" label="Clear Existing Demands" type="boolean" default="false"/>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)" default="LC"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import CourseDemand, CourseRequest, StudentSectioningStatus, StudentSectioningQueue
from java.util import Date, HashSet
from java.lang import Long
from __builtin__ import True

groups = hibSession.createQuery("from StudentGroup where session = :sid and type.reference = :ref").setLong("sid", session.getUniqueId()).setString("ref", groupTypeRef).list()

status = None
if statusRef:
    status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)
ts = Date()

students = HashSet()
studentFilter = None
if status:
   for student in hibSession.createQuery(
        "from Student where sectioningStatus.uniqueId = :statusId and session = :sessionId"
        ).setLong("sessionId", session.getUniqueId()).setLong("statusId", status.getUniqueId()).list():
       if not studentFilter: studentFilter = {}
       studentFilter[student.getUniqueId()] = True

for group in groups:
    reservations = hibSession.createQuery("from LearningCommunityReservation where group = :gid order by uniqueId").setLong("gid", group.getUniqueId()).list()
    courses = map(lambda r: r.getCourse(), reservations)
    log.info("%s: %s" % (group.getGroupAbbreviation(), ', '.join(map(lambda course: course.getCourseName(), courses))))
    for student in group.students:
        if studentFilter and student.getUniqueId() not in studentFilter:
            log.debug("Skipping %s %s (student status does not match)" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
            continue
        log.info("%s %s" % (student.getExternalUniqueId(), student.getName("last-first-middle")))
        if status: student.setSectioningStatus(status)
        if clear:
            for cd in student.getCourseDemands():
                if cd.getFreeTime(): hibSession.delete(cd.getFreeTime())
                for cr in cd.getCourseRequests(): hibSession.delete(cr)
                hibSession.delete(cd)
            student.getCourseDemands().clear()
            for enrl in student.getClassEnrollments(): hibSession.delete(enrl)
            student.getClassEnrollments().clear()
        priority = 0
        for cd in student.getCourseDemands():
            if priority <= cd.getPriority() and not cd.isAlternative(): priority = cd.getPriority() + 1
        for course in courses:
            included = False
            for cd in student.getCourseDemands():
                for cr in cd.getCourseRequests():
                    if cr.getCourseOffering() == course:
                        included = True
            if included: continue
            log.debug(course.getCourseNameWithTitle())
            cd = CourseDemand()
            cd.setCourseRequests(HashSet())
            cd.setStudent(student)
            student.getCourseDemands().add(cd)
            cd.setAlternative(False)
            cd.setPriority(priority)
            priority = priority + 1
            cd.setWaitlist(False)
            cd.setTimestamp(ts)
            cr = CourseRequest()
            cd.getCourseRequests().add(cr)
            cr.setCourseDemand(cd)
            cr.setAllowOverlap(False)
            cr.setCredit(0)
            cr.setOrder(0)
            cr.setCourseOffering(course)
        students.add(Long(student.getUniqueId()))
        hibSession.saveOrUpdate(student);
        
if students:
    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), students)]]></body>
</script>
<script name="Learning Communities: Student Import [with Names]" permission="Student Group Edit" engine="python" created="Tue Apr 18 11:46:47 EDT 2017">
  <description><![CDATA[This script imports students of one or more student groups according to the input CSV file in the following formats:
<ol><li>One line per student:<pre>
LC, PUID     , Name
G1, 752297072, John Snow
G1, 670857846, Abe Cam Street
  , 110163506, Will Smith
  , 685497415, Carl Kirk Nixon
G2, 565607184, Paul Ch Armstrong
  , 288674378, Al Roger Northrop
  , 845738199, Pat Oliver
  , 139074464, Evelyn Byron Fishman
</pre></li><li>One line per group:<pre>
LC, PUID1    , Name1            , PUID2    , Name2         , PUID3    , Name3     , ...
G1, 752297072, John Snow        , 670857846, Abe Cam Street, 110163506, Will Smith, 685497415
G2, 565607184, Paul Ch Armstrong, 288674378, Al R Northrop , 845738199, Pat Oliver, 139074464
</pre></li></ol>]]></description>
  <parameter name="nameColumns" label="Name Columns" type="enum(0,1,2,3,4)" default="1"/>
  <parameter name="updateSpace" label="Update Reserved Space" type="boolean" default="true"/>
  <parameter name="statusRef" label="status" type="reference(StudentSectioningStatus)" default="LC"/>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <parameter name="file" label="Input File" type="file"/>
  <parameter name="canCreateGroup" label="Create Groups" type="boolean" default="false"/>
  <body><![CDATA[import csv
from org.unitime.timetable.model import StudentSectioningQueue, StudentSectioningStatus, StudentGroup, StudentGroupType
from difflib import SequenceMatcher
from java.util import HashSet
from java.lang import Long
from __builtin__ import None

def lookupStudent(puid):
    student = hibSession.createQuery("from Student where session = :sessionId and externalUniqueId = :puid").setLong("sessionId", session.getUniqueId()).setString("puid", puid).setMaxResults(1).uniqueResult()
    if not student:
        log.warn("Student %s not found." % puid)
    else:
        log.debug("%s (%s)" % (student.getName("last-first-middle"), puid))
    return student

def match(name, student):
    if not name: return "N/A"
    nameFormats = ['first-last', 'last-first', 'first-middle-last', 'last-first-middle', 'initial-last', 'last-initial']
    ratio = 0.0
    for nf in nameFormats:
        r = SequenceMatcher(None, name, student.getName(nf)).ratio()
        if r > ratio: ratio = r
    return 100.0 * ratio

def enroll(students, lcAbbv, puids, status, writer):
    group = hibSession.createQuery("from StudentGroup where (groupAbbreviation = :abbv or groupName = :abbv) and session = :sessionId").setLong("sessionId", session.getUniqueId()).setString("abbv", lcAbbv).setMaxResults(1).uniqueResult();
    if not group and canCreateGroup:
      group = StudentGroup()
      group.setGroupAbbreviation(lcAbbv)
      group.setGroupName(lcAbbv)
      group.setSession(session)
      group.setStudents(HashSet())
      group.setType(StudentGroupType.findByReference(groupTypeRef, hibSession))
      hibSession.saveOrUpdate(group) 
    if not group:
        log.error("Student group %s does not exist." % lcAbbv)
        for (puid, name) in puids:
            student = lookupStudent(puid.lstrip("0"))
            if student:
                m = match(name, student)
                if m < 80.0: log.warn("Student %s has a weak match of %.2f%%: %s (import) versus %s (on file)" % (puid, m, name, student.getName("last-first-middle")))
                writer.writerow([lcAbbv, puid, name, student.getName("last-first-middle"), '%.2f' % m, student.getEmail(), "Student group %s does not exist." % lcAbbv])
            else:
                writer.writerow([lcAbbv, puid, name, None, None, None, "Student group %s does not exist.\nStudent %s not found." % (lcAbbv, puid)])
        return
    log.info("%s - %s" % (group.getGroupAbbreviation(), group.getGroupName()))
    group.getStudents().clear()
    for (puid, name) in puids:
        student = lookupStudent(puid.lstrip("0"))
        if student:
            group.getStudents().add(student)
            students.add(Long(student.getUniqueId()))
            m = match(name, student)
            if m < 80.0: log.warn("Student %s has a weak match of %.2f%%: %s (import) versus %s (on file)" % (puid, m, name, student.getName("last-first-middle")))
            writer.writerow([group.getGroupAbbreviation(), puid, name, student.getName("last-first-middle"), '%.2f' % m, student.getEmail()])
            if status:
                student.setSectioningStatus(status)
                hibSession.saveOrUpdate(student)
        else:
            writer.writerow([group.getGroupAbbreviation(), puid, name, None, None, None, "Student %s not found." % puid])
    hibSession.saveOrUpdate(group)
    if updateSpace:
        for r in hibSession.createQuery("from LearningCommunityReservation where group = :groupId").setLong("groupId", group.getUniqueId()).list():
            r.setLimit(len(puids))
            hibSession.saveOrUpdate(r)

lines = csv.reader(file.getString('utf-8').split('\n'), delimiter=",", quotechar='"')

status = None
if statusRef:
    status = StudentSectioningStatus.getStatus(statusRef, session.getUniqueId(), hibSession)

groups = {}
header = True
last = None
students = HashSet()
for line in lines:
    if not line:
        last = None
        continue

    lc = line[0].strip()
    if header:
        header = False
        if "LC" == lc: continue

    if not lc: lc = last
    last = lc
    if lc not in groups: groups[lc] = []
    idx = 1
    while idx < len(line):
        puid = line[idx]
        name = None
        if int(nameColumns) > 0:
            name = (' '.join(line[idx + 1: idx + int(nameColumns) + 1])).strip()
        if puid.strip():
             groups[lc].append((puid.strip(), name))
        idx = idx + 1 + int(nameColumns)

output = open(log.createOutput('lc-enrollment-results','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','PUID','Name (import)','Name (on file)','Name Match [%]','Email','Error'])
for lc in groups.keys():
    enroll(students, lc, groups[lc], status, writer)
writer.writerow(['EOF'])
output.close()

if students:
    StudentSectioningQueue.studentChanged(hibSession, None, session.getUniqueId(), students)]]></body>
</script>
<script name="Learning Communities: Reload Courses with LC Reservation" permission="Student Group Edit" engine="python" created="Thu Jun 22 11:26:22 EDT 2017">
  <description><![CDATA[This script will tell the online student scheduling server to reload all instructional offerings that have one or more learning community reservations. ]]></description>
  <body><![CDATA[from org.unitime.timetable.model import StudentSectioningQueue

offerings = hibSession.createQuery(
  "select r.instructionalOffering.uniqueId from LearningCommunityReservation r where r.instructionalOffering.session = :sessionId"
  ).setLong("sessionId", session.getUniqueId()).list()
StudentSectioningQueue.offeringChanged(hibSession, None, session.getUniqueId(), offerings)]]></body>
</script>
<script name="Learning Communities: Check Student Status [XE]" permission="Student Group Edit" engine="python" created="Thu Jun 22 10:52:40 EDT 2017">
  <description><![CDATA[This script is using Banner XE API to check all students of the given status and/or that meet the given student filter (same as on the Student Scheduling Solver page).
When <b>hold password</b> is provided, it is used when <font color='red'>Holds prevent registration.</font> error is returned.<br>
When <b>registration date</b> is provided, it is used when <font color='red'>Invalid or undefined Enrollment Status or date range invalid.</font> error is returned.
<br>
<br>Student Filter Examples:<ul>
<li>status:LC &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(all students of LC status)
<li>group:Animalia1 or group:Animalia2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(students of group Animalia1 or group Animalia2)
<li>area:A and classification:01 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(students of academic area A and academic classification 01)
</ul>]]></description>
  <parameter name="holdPassword" label="3. Hold Password" type="text"/>
  <parameter name="statusRef" label="1. Status" type="reference(StudentSectioningStatus)" default="LC"/>
  <parameter name="registrationDate" label="4. Registration Date (yyyy-mm-dd)" type="date"/>
  <parameter name="studentFilter" label="2. Student Filter" type="text" default=""/>
  <body><![CDATA[import csv
from java.util import ArrayList
from java.text import SimpleDateFormat
from org.restlet import Client
from org.restlet.data import Protocol, ChallengeScheme, MediaType
from org.restlet.resource import ClientResource, ResourceException
from org.unitime.timetable import ApplicationProperties
from org.unitime.timetable.onlinesectioning import AcademicSessionInfo
from org.unitime.timetable.onlinesectioning.custom.purdue import GsonRepresentation, XEInterface
from org.unitime.timetable.gwt.shared import SectioningException
from org.unitime.banner.onlinesectioning import BannerTermProvider
from org.unitime.timetable.gwt.server import Query
from org.unitime.timetable.onlinesectioning.status.db import DbFindEnrollmentInfoAction

def getClient():
    protocols = ArrayList()
    protocols.add(Protocol.HTTP)
    protocols.add(Protocol.HTTPS)
    return Client(protocols)

def getResource(client):
    resource = ClientResource(ApplicationProperties.getProperty("banner.xe.site"))
    resource.setNext(client)
    resource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, ApplicationProperties.getProperty("banner.xe.admin.user"), ApplicationProperties.getProperty("banner.xe.admin.password"))
    return resource

def getCourseNameForCrn(crn):
    course = hibSession.createQuery("select co from BannerSection bs, CourseOffering co where bs.session = :sessionId and bs.crn = :crn and bs.bannerConfig.bannerCourse.courseOfferingId = co.uniqueId").setLong("sessionId", session.getUniqueId()).setString("crn", crn).setMaxResults(1).uniqueResult()
    if course:
        return course.getCourseName()
    return None

def getSchedule(resource):
    try:
        resource.get(MediaType.APPLICATION_JSON)
    except ResourceException, e: handleError(resource, e)

    current = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse.TYPE_LIST).getObject()
    original = None
    if current and not current.isEmpty():
        original = current.get(0)

    if not original or not original.validStudent:
        reason = None
        if original and original.failureReasons:
            for m in original.failureReasons:
                if m == "Holds prevent registration." and holdPassword:
                    return (getHoldSchedule(resource), m)
                if m == "Invalid or undefined Enrollment Status or date range invalid." and registrationDate:
                    return (getHoldSchedule(resource), m)
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
        if reason: raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return (original, '')

def getHoldSchedule(resource):
    if holdPassword:
        log.debug("Using hold password...")
    elif registrationDate:
        log.debug("Using registration date...")
    term = resource.getQueryValue("term")
    puid = resource.getQueryValue("bannerId")
    req = XEInterface.RegisterRequest(term, puid, None, True)
    req.empty()
    if holdPassword:
        req.holdPassword = holdPassword
    if registrationDate:
        req.registrationDate = SimpleDateFormat('yyyy-MM-dd').format(registrationDate)

    try:
        resource.post(GsonRepresentation(req))
    except ResourceException, e: handleError(resource, e)

    response = GsonRepresentation(resource.getResponseEntity(), XEInterface.RegisterResponse).getObject()

    if not response:
        raise SectioningException("Failed to check student registration status.")
    elif not response.validStudent:
        reason = None
        if response.failureReasons:
            for m in response.failureReasons:
                if not reason:
                    reason = m
                else:
                    reason = '%s\n%s' % (reason, m)
                raise SectioningException(reason)
        raise SectioningException("Failed to check student registration status.")

    return response

def handleError(resource, e):
    error = None
    if resource.getResponseEntity():
        response = GsonRepresentation(resource.getResponseEntity(), XEInterface.ErrorResponse).getObject()
        if response: error = response.getError()
    if error and error.message:
        raise SectioningException(error.message)
    if error and error.description:
        raise SectioningException(error.description)
    if error and error.errorMessage:
        raise SectioningException(error.errorMessage)
    raise SectioningException(e.getMessage())

def check(client, student, writer):
    log.info('%s: %s' % (getPuid(student), getName(student)))
    resource = getResource(client)

    info = AcademicSessionInfo(session)
    bt = BannerTermProvider()
    term = bt.getExternalTerm(info)
    campus = bt.getExternalCampus(info)
    puid = str(getPuid(student)).zfill(9)

    resource.addQueryParameter("term", term)
    resource.addQueryParameter("bannerId", puid)
    resource.addQueryParameter("systemIn", "SB")
    resource.addQueryParameter("persona", "SB")
    if holdPassword:
        resource.addQueryParameter("holdPassword", holdPassword)

    (original, message) = getSchedule(resource)
    
    if original.registrations:
        for reg in original.registrations:
            log.debug('%s %s %s (%s)' % (reg.subject, reg.courseNumber, reg.courseReferenceNumber, reg.courseRegistrationStatus))
            writer.writerow([getPuid(student), getName(student), getGroup(student), getArea(student), getClassification(student), getMajor(student),
                '%s %s' % (reg.subject, reg.courseNumber), reg.courseReferenceNumber, reg.courseRegistrationStatus, reg.courseRegistrationStatusDescription, message])
    else:
        log.debug('%s has no enrollments.' % getName(student))
        writer.writerow([getPuid(student), getName(student), getGroup(student), getArea(student), getClassification(student), getMajor(student),
          '', '', '', '', message])

def getGroup(student):
    groups = []
    for g in student.groups:
        groups.append(g.groupAbbreviation)
    if groups: return '; '.join(groups)
    return None

def getArea(student):
    areas = []
    for acm in student.areaClasfMajors:
        areas.append(acm.academicArea.academicAreaAbbreviation)
    if areas: return '; '.join(areas)
    return None

def getClassification(student):
    clasf = []
    for acm in student.areaClasfMajors:
        clasf.append(acm.academicClassification.code)
    if clasf: return '; '.join(clasf)
    return None

def getMajor(student):
    major = []
    for acm in student.areaClasfMajors:
        major.append(acm.major.code)
    if major: return '; '.join(major)
    return None

def getName(student):
    return student.getName('last-first-middle')

def getPuid(student):
    return student.externalUniqueId

def checkStudent(client, student, writer):
    try:
        check(client, student, writer)
    except SectioningException, e:
        log.error('Check failed: %s' % e.getMessage())
        writer.writerow([getPuid(student), getName(student), getGroup(student), getArea(student), getClassification(student), getMajor(student),
          '', '', '', '', e.getMessage()])
if registrationDate:
    log.info('Registration date %s' % SimpleDateFormat('yyyy-MM-dd').format(registrationDate))
students = None
if statusRef:
    students = hibSession.createQuery(
        "from Student s where s.sectioningStatus.reference = :statusRef and s.session = :sessionId order by s.lastName, s.firstName"
        ).setString("statusRef", statusRef).setLong("sessionId", session.getUniqueId()).list()
else:
    students = hibSession.createQuery(
        "from Student s where s.session = :sessionId order by s.lastName, s.firstName"
        ).setLong("sessionId", session.getUniqueId()).list()
query = None
if studentFilter:
    query = Query(studentFilter)
client = getClient()
output = open(log.createOutput('students','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['PUID','Name','Group', 'Area', 'Clasf', 'Major', 'Course', 'CRN', 'Status', 'Status Description', 'Error'])
log.setStatus('Checking students', len(students))
for student in students:
    log.incProgress()
    if query and not query.match(DbFindEnrollmentInfoAction.DbStudentMatcher(student)):
        continue
    checkStudent(client, student, writer)
writer.writerow(['EOF'])
output.close()]]></body>
</script>
<script name="Learning Communities: Course Matrix Export" permission="Student Groups" engine="python" created="Thu Jun 22 09:30:22 EDT 2017">
  <description><![CDATA[This script exports student groups and student group reservations to a CSV file.]]></description>
  <parameter name="groupTypeRef" label="Group Type" type="reference(StudentGroupType)" default="LC"/>
  <body><![CDATA[import csv

def groupSize(group):
    if group.expectedSize: return str(group.expectedSize)
    if group.students: return str(group.students.size())
    return ''

groups = hibSession.createQuery(
    "from StudentGroup g where g.session = :sessionId and g.type.reference = :ref order by g.groupAbbreviation"
    ).setLong("sessionId", session.getUniqueId()).setString("ref", groupTypeRef).list()

output = open(log.createOutput('learning-communities','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
writer.writerow(['LC','Name','Size', 'Subj', 'Course', 'CRN1', 'CRN2', 'CRN3', 'CRN4'])

for g in groups:
    firstLine = True
    reservations = hibSession.createQuery(
        "from LearningCommunityReservation r where r.group = :groupId"
        ).setLong("groupId", g.uniqueId).list()
    for r in reservations:
      line = None
      if firstLine:
          firstLine = False
          line = [g.groupAbbreviation, g.groupName, groupSize(g)]
      else:
          line = ['','','']
      line.append(r.course.subjectAreaAbbv)
      line.append(r.course.courseNbr)
      for c in r.classes:
          line.append(c.getExternalId(r.course))
      writer.writerow(line)
    if firstLine:
        writer.writerow([g.groupAbbreviation, g.groupName, groupSize(g)])
writer.writerow(['EOF'])
output.close()]]></body>
</script>
<script name="Learning Communities: Student Export" permission="Student Groups" engine="python" created="Thu Jun 22 09:14:25 EDT 2017">
  <description><![CDATA[This script exports students of all student groups that have the given status.]]></description>
  <parameter name="exportNames" label="Export Student Names" type="boolean" default="true"/>
  <parameter name="statusRef" label="Status" type="reference(StudentSectioningStatus)"/>
  <body><![CDATA[import csv
from java.util import TreeSet

groups = hibSession.createQuery(
    "from StudentGroup g where g.session = :sessionId order by g.groupAbbreviation"
    ).setLong("sessionId", session.getUniqueId()).list()

output = open(log.createOutput('students','csv').getAbsolutePath(), 'w')
writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
if exportNames:
    writer.writerow(['LC','PUID','Name'])
else:
    writer.writerow(['LC','PUID1','PUID2','PUID3','PUID4'])
for g in groups:
    students = None
    if statusRef:
        students = TreeSet()
        for s in g.students:
            if s.sectioningStatus and statusRef == s.sectioningStatus.reference: students.add(s)
    else:
        students = TreeSet(g.students)
    if not students: continue
    if exportNames:
        for s in students:
            writer.writerow([g.groupAbbreviation, s.externalUniqueId, s.getName('last-first-middle')])
    else:
        line = [g.groupAbbreviation]
        for s in students:
            line.append(s.externalUniqueId)
        writer.writerow(line)
writer.writerow(['EOF'])
output.close()]]></body>
</script>
</scripts>